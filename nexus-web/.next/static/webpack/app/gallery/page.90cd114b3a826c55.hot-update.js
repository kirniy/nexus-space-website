"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gallery/page",{

/***/ "(app-pages-browser)/./src/components/ui/DomeGallery.tsx":
/*!*******************************************!*\
  !*** ./src/components/ui/DomeGallery.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DomeGallery; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _use_gesture_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/react */ \"(app-pages-browser)/./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst DEFAULT_IMAGES = [\n    \"/photo_2025-09-20_00-35-13.jpeg\",\n    \"/photo_2025-09-20_00-35-14.jpeg\",\n    \"/photo_2025-09-20_00-35-16.jpeg\",\n    \"/photo_2025-09-20_00-35-17.jpeg\",\n    \"/photo_2025-09-20_00-35-18.jpeg\",\n    \"/photo_2025-09-20_00-35-19.jpeg\",\n    \"/photo_2025-09-20_00-35-22.jpeg\",\n    \"/photo_2025-09-20_00-35-23.jpeg\"\n];\nconst DEFAULTS = {\n    maxVerticalRotationDeg: 5,\n    dragSensitivity: 20,\n    enlargeTransitionMs: 300,\n    segments: 35\n};\nconst clamp = (v, min, max)=>Math.min(Math.max(v, min), max);\nconst normalizeAngle = (d)=>(d % 360 + 360) % 360;\nconst wrapAngleSigned = (deg)=>{\n    const a = ((deg + 180) % 360 + 360) % 360;\n    return a - 180;\n};\nconst getDataNumber = (el, name, fallback)=>{\n    var _el_dataset_name;\n    const attr = (_el_dataset_name = el.dataset[name]) !== null && _el_dataset_name !== void 0 ? _el_dataset_name : el.getAttribute(\"data-\".concat(name));\n    const n = attr == null ? NaN : parseFloat(attr);\n    return Number.isFinite(n) ? n : fallback;\n};\nfunction buildItems(pool, seg) {\n    const xCols = Array.from({\n        length: seg\n    }, (_, i)=>-37 + i * 2);\n    const evenYs = [\n        -4,\n        -2,\n        0,\n        2,\n        4\n    ];\n    const oddYs = [\n        -3,\n        -1,\n        1,\n        3,\n        5\n    ];\n    const coords = xCols.flatMap((x, c)=>{\n        const ys = c % 2 === 0 ? evenYs : oddYs;\n        return ys.map((y)=>({\n                x,\n                y,\n                sizeX: 2,\n                sizeY: 2\n            }));\n    });\n    const totalSlots = coords.length;\n    if (pool.length === 0) {\n        return coords.map((c)=>({\n                ...c,\n                src: \"\",\n                alt: \"\"\n            }));\n    }\n    if (pool.length > totalSlots) {\n        console.warn(\"[DomeGallery] Provided image count (\".concat(pool.length, \") exceeds available tiles (\").concat(totalSlots, \"). Some images will not be shown.\"));\n    }\n    const normalizedImages = pool.map((image)=>{\n        if (typeof image === \"string\") {\n            return {\n                src: image,\n                alt: \"\"\n            };\n        }\n        return {\n            src: image.src || \"\",\n            alt: image.alt || \"\"\n        };\n    });\n    const usedImages = Array.from({\n        length: totalSlots\n    }, (_, i)=>normalizedImages[i % normalizedImages.length]);\n    for(let i = 1; i < usedImages.length; i++){\n        if (usedImages[i].src === usedImages[i - 1].src) {\n            for(let j = i + 1; j < usedImages.length; j++){\n                if (usedImages[j].src !== usedImages[i].src) {\n                    const tmp = usedImages[i];\n                    usedImages[i] = usedImages[j];\n                    usedImages[j] = tmp;\n                    break;\n                }\n            }\n        }\n    }\n    return coords.map((c, i)=>({\n            ...c,\n            src: usedImages[i].src,\n            alt: usedImages[i].alt\n        }));\n}\nfunction computeItemBaseRotation(offsetX, offsetY, sizeX, sizeY, segments) {\n    const unit = 360 / segments / 2;\n    const rotateY = unit * (offsetX + (sizeX - 1) / 2);\n    const rotateX = unit * (offsetY - (sizeY - 1) / 2);\n    return {\n        rotateX,\n        rotateY\n    };\n}\nfunction DomeGallery(param) {\n    let { images = DEFAULT_IMAGES, fit = 0.5, fitBasis = \"auto\", minRadius = 600, maxRadius = Infinity, padFactor = 0.25, overlayBlurColor = \"#060010\", maxVerticalRotationDeg = DEFAULTS.maxVerticalRotationDeg, dragSensitivity = DEFAULTS.dragSensitivity, enlargeTransitionMs = DEFAULTS.enlargeTransitionMs, segments = DEFAULTS.segments, dragDampening = 2, openedImageWidth = \"400px\", openedImageHeight = \"400px\", imageBorderRadius = \"30px\", openedImageBorderRadius = \"30px\", grayscale = true } = param;\n    _s();\n    const rootRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sphereRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const viewerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const scrimRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const focusedElRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const originalTilePositionRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rotationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const startRotRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const startPosRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const draggingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const cancelTapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const movedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const inertiaRAF = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const pointerTypeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"mouse\");\n    const tapTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const openingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const openStartedAtRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const lastDragEndAt = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const scrollLockedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const lockScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (scrollLockedRef.current) return;\n        scrollLockedRef.current = true;\n        document.body.classList.add(\"dg-scroll-lock\");\n    }, []);\n    const unlockScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _rootRef_current;\n        if (!scrollLockedRef.current) return;\n        if (((_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.getAttribute(\"data-enlarging\")) === \"true\") return;\n        scrollLockedRef.current = false;\n        document.body.classList.remove(\"dg-scroll-lock\");\n    }, []);\n    const items = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const builtItems = buildItems(images, segments);\n        console.log(\"DomeGallery items:\", builtItems);\n        console.log(\"Images array:\", images);\n        return builtItems;\n    }, [\n        images,\n        segments\n    ]);\n    const applyTransform = (xDeg, yDeg)=>{\n        const el = sphereRef.current;\n        if (el) {\n            el.style.transform = \"translateZ(calc(var(--radius) * -1)) rotateX(\".concat(xDeg, \"deg) rotateY(\").concat(yDeg, \"deg)\");\n        }\n    };\n    const lockedRadiusRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const root = rootRef.current;\n        if (!root) return;\n        const ro = new ResizeObserver((entries)=>{\n            var _viewerRef_current;\n            const cr = entries[0].contentRect;\n            const w = Math.max(1, cr.width), h = Math.max(1, cr.height);\n            const minDim = Math.min(w, h), maxDim = Math.max(w, h), aspect = w / h;\n            let basis;\n            switch(fitBasis){\n                case \"min\":\n                    basis = minDim;\n                    break;\n                case \"max\":\n                    basis = maxDim;\n                    break;\n                case \"width\":\n                    basis = w;\n                    break;\n                case \"height\":\n                    basis = h;\n                    break;\n                default:\n                    basis = aspect >= 1.3 ? w : minDim;\n            }\n            let radius = basis * fit;\n            const heightGuard = h * 1.35;\n            radius = Math.min(radius, heightGuard);\n            radius = clamp(radius, minRadius, maxRadius);\n            lockedRadiusRef.current = Math.round(radius);\n            const viewerPad = Math.max(8, Math.round(minDim * padFactor));\n            console.log(\"Setting CSS variables:\", {\n                radius: lockedRadiusRef.current,\n                viewerPad,\n                dimensions: {\n                    w,\n                    h\n                }\n            });\n            root.style.setProperty(\"--radius\", \"\".concat(lockedRadiusRef.current, \"px\"));\n            root.style.setProperty(\"--viewer-pad\", \"\".concat(viewerPad, \"px\"));\n            root.style.setProperty(\"--overlay-blur-color\", overlayBlurColor);\n            root.style.setProperty(\"--tile-radius\", imageBorderRadius);\n            root.style.setProperty(\"--enlarge-radius\", openedImageBorderRadius);\n            root.style.setProperty(\"--image-filter\", grayscale ? \"grayscale(1)\" : \"none\");\n            applyTransform(rotationRef.current.x, rotationRef.current.y);\n            const enlargedOverlay = (_viewerRef_current = viewerRef.current) === null || _viewerRef_current === void 0 ? void 0 : _viewerRef_current.querySelector(\".enlarge\");\n            if (enlargedOverlay && frameRef.current && mainRef.current) {\n                const frameR = frameRef.current.getBoundingClientRect();\n                const mainR = mainRef.current.getBoundingClientRect();\n                const hasCustomSize = openedImageWidth && openedImageHeight;\n                if (hasCustomSize) {\n                    const tempDiv = document.createElement(\"div\");\n                    tempDiv.style.cssText = \"position: absolute; width: \".concat(openedImageWidth, \"; height: \").concat(openedImageHeight, \"; visibility: hidden;\");\n                    document.body.appendChild(tempDiv);\n                    const tempRect = tempDiv.getBoundingClientRect();\n                    document.body.removeChild(tempDiv);\n                    const centeredLeft = frameR.left - mainR.left + (frameR.width - tempRect.width) / 2;\n                    const centeredTop = frameR.top - mainR.top + (frameR.height - tempRect.height) / 2;\n                    enlargedOverlay.style.left = \"\".concat(centeredLeft, \"px\");\n                    enlargedOverlay.style.top = \"\".concat(centeredTop, \"px\");\n                } else {\n                    enlargedOverlay.style.left = \"\".concat(frameR.left - mainR.left, \"px\");\n                    enlargedOverlay.style.top = \"\".concat(frameR.top - mainR.top, \"px\");\n                    enlargedOverlay.style.width = \"\".concat(frameR.width, \"px\");\n                    enlargedOverlay.style.height = \"\".concat(frameR.height, \"px\");\n                }\n            }\n        });\n        ro.observe(root);\n        return ()=>ro.disconnect();\n    }, [\n        fit,\n        fitBasis,\n        minRadius,\n        maxRadius,\n        padFactor,\n        overlayBlurColor,\n        grayscale,\n        imageBorderRadius,\n        openedImageBorderRadius,\n        openedImageWidth,\n        openedImageHeight\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        applyTransform(rotationRef.current.x, rotationRef.current.y);\n    }, []);\n    const stopInertia = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (inertiaRAF.current) {\n            cancelAnimationFrame(inertiaRAF.current);\n            inertiaRAF.current = null;\n        }\n    }, []);\n    const startInertia = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((vx, vy)=>{\n        const MAX_V = 1.4;\n        let vX = clamp(vx, -MAX_V, MAX_V) * 80;\n        let vY = clamp(vy, -MAX_V, MAX_V) * 80;\n        let frames = 0;\n        const d = clamp(dragDampening !== null && dragDampening !== void 0 ? dragDampening : 0.6, 0, 1);\n        const frictionMul = 0.94 + 0.055 * d;\n        const stopThreshold = 0.015 - 0.01 * d;\n        const maxFrames = Math.round(90 + 270 * d);\n        const step = ()=>{\n            vX *= frictionMul;\n            vY *= frictionMul;\n            if (Math.abs(vX) < stopThreshold && Math.abs(vY) < stopThreshold) {\n                inertiaRAF.current = null;\n                return;\n            }\n            if (++frames > maxFrames) {\n                inertiaRAF.current = null;\n                return;\n            }\n            const nextX = clamp(rotationRef.current.x - vY / 200, -maxVerticalRotationDeg, maxVerticalRotationDeg);\n            const nextY = wrapAngleSigned(rotationRef.current.y + vX / 200);\n            rotationRef.current = {\n                x: nextX,\n                y: nextY\n            };\n            applyTransform(nextX, nextY);\n            inertiaRAF.current = requestAnimationFrame(step);\n        };\n        stopInertia();\n        inertiaRAF.current = requestAnimationFrame(step);\n    }, [\n        dragDampening,\n        maxVerticalRotationDeg,\n        stopInertia\n    ]);\n    (0,_use_gesture_react__WEBPACK_IMPORTED_MODULE_2__.useGesture)({\n        onDragStart: (param)=>{\n            let { event } = param;\n            var _evt_target_closest, _evt_target;\n            if (focusedElRef.current) return;\n            stopInertia();\n            const evt = event;\n            pointerTypeRef.current = evt.pointerType || \"mouse\";\n            if (pointerTypeRef.current === \"touch\") evt.preventDefault();\n            if (pointerTypeRef.current === \"touch\") lockScroll();\n            draggingRef.current = true;\n            cancelTapRef.current = false;\n            movedRef.current = false;\n            startRotRef.current = {\n                ...rotationRef.current\n            };\n            startPosRef.current = {\n                x: evt.clientX,\n                y: evt.clientY\n            };\n            const potential = (_evt_target_closest = (_evt_target = evt.target).closest) === null || _evt_target_closest === void 0 ? void 0 : _evt_target_closest.call(_evt_target, \".item__image\");\n            tapTargetRef.current = potential || null;\n        },\n        onDrag: (param)=>{\n            let { event, last, velocity: velArr = [\n                0,\n                0\n            ], direction: dirArr = [\n                0,\n                0\n            ], movement } = param;\n            if (focusedElRef.current || !draggingRef.current || !startPosRef.current) return;\n            const evt = event;\n            if (pointerTypeRef.current === \"touch\") evt.preventDefault();\n            const dxTotal = evt.clientX - startPosRef.current.x;\n            const dyTotal = evt.clientY - startPosRef.current.y;\n            if (!movedRef.current) {\n                const dist2 = dxTotal * dxTotal + dyTotal * dyTotal;\n                if (dist2 > 16) movedRef.current = true;\n            }\n            const nextX = clamp(startRotRef.current.x - dyTotal / dragSensitivity, -maxVerticalRotationDeg, maxVerticalRotationDeg);\n            const nextY = startRotRef.current.y + dxTotal / dragSensitivity;\n            const cur = rotationRef.current;\n            if (cur.x !== nextX || cur.y !== nextY) {\n                rotationRef.current = {\n                    x: nextX,\n                    y: nextY\n                };\n                applyTransform(nextX, nextY);\n            }\n            if (last) {\n                draggingRef.current = false;\n                let isTap = false;\n                if (startPosRef.current) {\n                    const dx = evt.clientX - startPosRef.current.x;\n                    const dy = evt.clientY - startPosRef.current.y;\n                    const dist2 = dx * dx + dy * dy;\n                    const TAP_THRESH_PX = pointerTypeRef.current === \"touch\" ? 10 : 6;\n                    if (dist2 <= TAP_THRESH_PX * TAP_THRESH_PX) {\n                        isTap = true;\n                    }\n                }\n                let [vMagX, vMagY] = velArr;\n                const [dirX, dirY] = dirArr;\n                let vx = vMagX * dirX;\n                let vy = vMagY * dirY;\n                if (!isTap && Math.abs(vx) < 0.001 && Math.abs(vy) < 0.001 && Array.isArray(movement)) {\n                    const [mx, my] = movement;\n                    vx = mx / dragSensitivity * 0.02;\n                    vy = my / dragSensitivity * 0.02;\n                }\n                if (!isTap && (Math.abs(vx) > 0.005 || Math.abs(vy) > 0.005)) {\n                    startInertia(vx, vy);\n                }\n                startPosRef.current = null;\n                cancelTapRef.current = !isTap;\n                if (isTap && tapTargetRef.current && !focusedElRef.current) {\n                    openItemFromElement(tapTargetRef.current);\n                }\n                tapTargetRef.current = null;\n                if (cancelTapRef.current) setTimeout(()=>cancelTapRef.current = false, 120);\n                if (pointerTypeRef.current === \"touch\") unlockScroll();\n                if (movedRef.current) lastDragEndAt.current = performance.now();\n                movedRef.current = false;\n            }\n        }\n    }, {\n        target: mainRef,\n        eventOptions: {\n            passive: false\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const scrim = scrimRef.current;\n        if (!scrim) return;\n        const close = ()=>{\n            var _viewerRef_current;\n            if (performance.now() - openStartedAtRef.current < 250) return;\n            const el = focusedElRef.current;\n            if (!el) return;\n            const parent = el.parentElement;\n            const overlay = (_viewerRef_current = viewerRef.current) === null || _viewerRef_current === void 0 ? void 0 : _viewerRef_current.querySelector(\".enlarge\");\n            if (!overlay) return;\n            const refDiv = parent.querySelector(\".item__image--reference\");\n            const originalPos = originalTilePositionRef.current;\n            if (!originalPos) {\n                var _rootRef_current;\n                overlay.remove();\n                if (refDiv) refDiv.remove();\n                parent.style.setProperty(\"--rot-y-delta\", \"0deg\");\n                parent.style.setProperty(\"--rot-x-delta\", \"0deg\");\n                el.style.visibility = \"\";\n                el.style.zIndex = 0;\n                focusedElRef.current = null;\n                (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.removeAttribute(\"data-enlarging\");\n                openingRef.current = false;\n                return;\n            }\n            const currentRect = overlay.getBoundingClientRect();\n            const rootRect = rootRef.current.getBoundingClientRect();\n            const originalPosRelativeToRoot = {\n                left: originalPos.left - rootRect.left,\n                top: originalPos.top - rootRect.top,\n                width: originalPos.width,\n                height: originalPos.height\n            };\n            const overlayRelativeToRoot = {\n                left: currentRect.left - rootRect.left,\n                top: currentRect.top - rootRect.top,\n                width: currentRect.width,\n                height: currentRect.height\n            };\n            const animatingOverlay = document.createElement(\"div\");\n            animatingOverlay.className = \"enlarge-closing\";\n            animatingOverlay.style.cssText = \"\\n        position: absolute;\\n        left: \".concat(overlayRelativeToRoot.left, \"px;\\n        top: \").concat(overlayRelativeToRoot.top, \"px;\\n        width: \").concat(overlayRelativeToRoot.width, \"px;\\n        height: \").concat(overlayRelativeToRoot.height, \"px;\\n        z-index: 9999;\\n        border-radius: \").concat(openedImageBorderRadius, \";\\n        overflow: hidden;\\n        box-shadow: 0 10px 30px rgba(0,0,0,.35);\\n        transition: all \").concat(enlargeTransitionMs, \"ms ease-out;\\n        pointer-events: none;\\n        margin: 0;\\n        transform: none;\\n        filter: \").concat(grayscale ? \"grayscale(1)\" : \"none\", \";\\n      \");\n            const originalImg = overlay.querySelector(\"img\");\n            if (originalImg) {\n                const img = originalImg.cloneNode();\n                img.style.cssText = \"width: 100%; height: 100%; object-fit: cover;\";\n                animatingOverlay.appendChild(img);\n            }\n            overlay.remove();\n            rootRef.current.appendChild(animatingOverlay);\n            void animatingOverlay.getBoundingClientRect();\n            requestAnimationFrame(()=>{\n                animatingOverlay.style.left = originalPosRelativeToRoot.left + \"px\";\n                animatingOverlay.style.top = originalPosRelativeToRoot.top + \"px\";\n                animatingOverlay.style.width = originalPosRelativeToRoot.width + \"px\";\n                animatingOverlay.style.height = originalPosRelativeToRoot.height + \"px\";\n                animatingOverlay.style.opacity = \"0\";\n            });\n            const cleanup = ()=>{\n                animatingOverlay.remove();\n                originalTilePositionRef.current = null;\n                if (refDiv) refDiv.remove();\n                parent.style.transition = \"none\";\n                el.style.transition = \"none\";\n                parent.style.setProperty(\"--rot-y-delta\", \"0deg\");\n                parent.style.setProperty(\"--rot-x-delta\", \"0deg\");\n                requestAnimationFrame(()=>{\n                    var _rootRef_current;\n                    el.style.visibility = \"\";\n                    el.style.opacity = \"0\";\n                    el.style.zIndex = 0;\n                    focusedElRef.current = null;\n                    (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.removeAttribute(\"data-enlarging\");\n                    requestAnimationFrame(()=>{\n                        parent.style.transition = \"\";\n                        el.style.transition = \"opacity 300ms ease-out\";\n                        requestAnimationFrame(()=>{\n                            el.style.opacity = \"1\";\n                            setTimeout(()=>{\n                                var _rootRef_current;\n                                el.style.transition = \"\";\n                                el.style.opacity = \"\";\n                                openingRef.current = false;\n                                if (!draggingRef.current && ((_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.getAttribute(\"data-enlarging\")) !== \"true\") {\n                                    document.body.classList.remove(\"dg-scroll-lock\");\n                                }\n                            }, 300);\n                        });\n                    });\n                });\n            };\n            animatingOverlay.addEventListener(\"transitionend\", cleanup, {\n                once: true\n            });\n        };\n        scrim.addEventListener(\"click\", close);\n        const onKey = (e)=>{\n            if (e.key === \"Escape\") close();\n        };\n        window.addEventListener(\"keydown\", onKey);\n        return ()=>{\n            scrim.removeEventListener(\"click\", close);\n            window.removeEventListener(\"keydown\", onKey);\n        };\n    }, [\n        enlargeTransitionMs,\n        openedImageBorderRadius,\n        grayscale\n    ]);\n    const openItemFromElement = (el)=>{\n        var _el_querySelector, _el_querySelector1;\n        if (cancelTapRef.current) return;\n        if (openingRef.current) return;\n        openingRef.current = true;\n        openStartedAtRef.current = performance.now();\n        lockScroll();\n        const parent = el.parentElement;\n        focusedElRef.current = el;\n        el.setAttribute(\"data-focused\", \"true\");\n        const offsetX = getDataNumber(parent, \"offsetX\", 0);\n        const offsetY = getDataNumber(parent, \"offsetY\", 0);\n        const sizeX = getDataNumber(parent, \"sizeX\", 2);\n        const sizeY = getDataNumber(parent, \"sizeY\", 2);\n        const parentRot = computeItemBaseRotation(offsetX, offsetY, sizeX, sizeY, segments);\n        const parentY = normalizeAngle(parentRot.rotateY);\n        const globalY = normalizeAngle(rotationRef.current.y);\n        let rotY = -(parentY + globalY) % 360;\n        if (rotY < -180) rotY += 360;\n        const rotX = -parentRot.rotateX - rotationRef.current.x;\n        parent.style.setProperty(\"--rot-y-delta\", \"\".concat(rotY, \"deg\"));\n        parent.style.setProperty(\"--rot-x-delta\", \"\".concat(rotX, \"deg\"));\n        const refDiv = document.createElement(\"div\");\n        refDiv.className = \"item__image item__image--reference opacity-0\";\n        refDiv.style.transform = \"rotateX(\".concat(-parentRot.rotateX, \"deg) rotateY(\").concat(-parentRot.rotateY, \"deg)\");\n        parent.appendChild(refDiv);\n        const tileR = refDiv.getBoundingClientRect();\n        const mainR = mainRef.current.getBoundingClientRect();\n        const frameR = frameRef.current.getBoundingClientRect();\n        originalTilePositionRef.current = {\n            left: tileR.left,\n            top: tileR.top,\n            width: tileR.width,\n            height: tileR.height\n        };\n        el.style.visibility = \"hidden\";\n        el.style.zIndex = 0;\n        const overlay = document.createElement(\"div\");\n        overlay.className = \"enlarge\";\n        overlay.style.cssText = \"position:absolute; left:\".concat(frameR.left - mainR.left, \"px; top:\").concat(frameR.top - mainR.top, \"px; width:\").concat(frameR.width, \"px; height:\").concat(frameR.height, \"px; opacity:0; z-index:30; will-change:transform,opacity; transform-origin:top left; transition:transform \").concat(enlargeTransitionMs, \"ms ease, opacity \").concat(enlargeTransitionMs, \"ms ease; border-radius:\").concat(openedImageBorderRadius, \"; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35);\");\n        const rawSrc = parent.dataset.src || ((_el_querySelector = el.querySelector(\"img\")) === null || _el_querySelector === void 0 ? void 0 : _el_querySelector.src) || \"\";\n        const rawAlt = parent.dataset.alt || ((_el_querySelector1 = el.querySelector(\"img\")) === null || _el_querySelector1 === void 0 ? void 0 : _el_querySelector1.alt) || \"\";\n        const img = document.createElement(\"img\");\n        img.src = rawSrc;\n        img.alt = rawAlt;\n        img.style.cssText = \"width:100%; height:100%; object-fit:cover; filter:\".concat(grayscale ? \"grayscale(1)\" : \"none\", \";\");\n        overlay.appendChild(img);\n        viewerRef.current.appendChild(overlay);\n        const tx0 = tileR.left - frameR.left;\n        const ty0 = tileR.top - frameR.top;\n        const sx0 = tileR.width / frameR.width;\n        const sy0 = tileR.height / frameR.height;\n        overlay.style.transform = \"translate(\".concat(tx0, \"px, \").concat(ty0, \"px) scale(\").concat(sx0, \", \").concat(sy0, \")\");\n        requestAnimationFrame(()=>{\n            var _rootRef_current;\n            overlay.style.opacity = \"1\";\n            overlay.style.transform = \"translate(0px, 0px) scale(1, 1)\";\n            (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.setAttribute(\"data-enlarging\", \"true\");\n        });\n        const wantsResize = openedImageWidth || openedImageHeight;\n        if (wantsResize) {\n            const onFirstEnd = (ev)=>{\n                if (ev.propertyName !== \"transform\") return;\n                overlay.removeEventListener(\"transitionend\", onFirstEnd);\n                const prevTransition = overlay.style.transition;\n                overlay.style.transition = \"none\";\n                const tempWidth = openedImageWidth || \"\".concat(frameR.width, \"px\");\n                const tempHeight = openedImageHeight || \"\".concat(frameR.height, \"px\");\n                overlay.style.width = tempWidth;\n                overlay.style.height = tempHeight;\n                const newRect = overlay.getBoundingClientRect();\n                overlay.style.width = frameR.width + \"px\";\n                overlay.style.height = frameR.height + \"px\";\n                void overlay.offsetWidth;\n                overlay.style.transition = \"left \".concat(enlargeTransitionMs, \"ms ease, top \").concat(enlargeTransitionMs, \"ms ease, width \").concat(enlargeTransitionMs, \"ms ease, height \").concat(enlargeTransitionMs, \"ms ease\");\n                const centeredLeft = frameR.left - mainR.left + (frameR.width - newRect.width) / 2;\n                const centeredTop = frameR.top - mainR.top + (frameR.height - newRect.height) / 2;\n                requestAnimationFrame(()=>{\n                    overlay.style.left = \"\".concat(centeredLeft, \"px\");\n                    overlay.style.top = \"\".concat(centeredTop, \"px\");\n                    overlay.style.width = tempWidth;\n                    overlay.style.height = tempHeight;\n                });\n                const cleanupSecond = ()=>{\n                    overlay.removeEventListener(\"transitionend\", cleanupSecond);\n                    overlay.style.transition = prevTransition;\n                };\n                overlay.addEventListener(\"transitionend\", cleanupSecond, {\n                    once: true\n                });\n            };\n            overlay.addEventListener(\"transitionend\", onFirstEnd);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            document.body.classList.remove(\"dg-scroll-lock\");\n        };\n    }, []);\n    const cssStyles = '\\n    .sphere-root {\\n      --radius: 800px;\\n      --viewer-pad: 72px;\\n      --circ: calc(var(--radius) * 3.14);\\n      --rot-y: calc((360deg / var(--segments-x)) / 2);\\n      --rot-x: calc((360deg / var(--segments-y)) / 2);\\n      --item-width: calc(var(--circ) / var(--segments-x));\\n      --item-height: calc(var(--circ) / var(--segments-y));\\n    }\\n\\n    .sphere-root * { box-sizing: border-box; }\\n    .sphere, .sphere-item, .item__image { transform-style: preserve-3d; }\\n\\n    .stage {\\n      width: 100%;\\n      height: 100%;\\n      display: grid;\\n      place-items: center;\\n      position: absolute;\\n      inset: 0;\\n      margin: auto;\\n      perspective: calc(var(--radius) * 2);\\n      perspective-origin: 50% 50%;\\n    }\\n\\n    .sphere {\\n      transform: translateZ(calc(var(--radius) * -1));\\n      will-change: transform;\\n      position: absolute;\\n      /* Debug: make sphere visible */\\n      width: 200px;\\n      height: 200px;\\n      pointer-events: none;\\n    }\\n\\n    .sphere-item {\\n      width: calc(var(--item-width) * var(--item-size-x));\\n      height: calc(var(--item-height) * var(--item-size-y));\\n      position: absolute;\\n      top: -999px;\\n      bottom: -999px;\\n      left: -999px;\\n      right: -999px;\\n      margin: auto;\\n      transform-origin: 50% 50%;\\n      backface-visibility: hidden;\\n      transition: transform 300ms;\\n      transform: rotateY(calc(var(--rot-y) * (var(--offset-x) + ((var(--item-size-x) - 1) / 2)) + var(--rot-y-delta, 0deg)))\\n                 rotateX(calc(var(--rot-x) * (var(--offset-y) - ((var(--item-size-y) - 1) / 2)) + var(--rot-x-delta, 0deg)))\\n                 translateZ(var(--radius));\\n    }\\n\\n    .sphere-root[data-enlarging=\"true\"] .scrim {\\n      opacity: 1 !important;\\n      pointer-events: all !important;\\n    }\\n\\n    @media (max-aspect-ratio: 1/1) {\\n      .viewer-frame {\\n        height: auto !important;\\n        width: 100% !important;\\n      }\\n    }\\n\\n    /* body.dg-scroll-lock {\\n      position: fixed !important;\\n      top: 0;\\n      left: 0;\\n      width: 100% !important;\\n      height: 100% !important;\\n      overflow: hidden !important;\\n      touch-action: none !important;\\n      overscroll-behavior: contain !important;\\n    } */\\n    .item__image {\\n      position: absolute;\\n      inset: 10px;\\n      border-radius: var(--tile-radius, 12px);\\n      overflow: hidden;\\n      cursor: pointer;\\n      backface-visibility: hidden;\\n      -webkit-backface-visibility: hidden;\\n      transition: transform 300ms;\\n      pointer-events: auto;\\n      -webkit-transform: translateZ(0);\\n      transform: translateZ(0);\\n    }\\n    .item__image--reference {\\n      position: absolute;\\n      inset: 10px;\\n      pointer-events: none;\\n    }\\n  ';\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                dangerouslySetInnerHTML: {\n                    __html: cssStyles\n                }\n            }, void 0, false, {\n                fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                lineNumber: 754,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: rootRef,\n                className: \"sphere-root relative w-full h-full bg-red-500/10\",\n                style: {\n                    [\"--segments-x\"]: segments,\n                    [\"--segments-y\"]: segments,\n                    [\"--overlay-blur-color\"]: overlayBlurColor,\n                    [\"--tile-radius\"]: imageBorderRadius,\n                    [\"--enlarge-radius\"]: openedImageBorderRadius,\n                    [\"--image-filter\"]: grayscale ? \"grayscale(1)\" : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                    ref: mainRef,\n                    className: \"absolute inset-0 grid place-items-center overflow-hidden select-none bg-green-500/10\",\n                    style: {\n                        touchAction: \"none\",\n                        WebkitUserSelect: \"none\",\n                        pointerEvents: \"auto\",\n                        zIndex: 1\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"stage bg-blue-500/10\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: sphereRef,\n                                className: \"sphere bg-yellow-500/10\",\n                                children: items.map((it, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"sphere-item absolute m-auto\",\n                                        \"data-src\": it.src,\n                                        \"data-alt\": it.alt,\n                                        \"data-offset-x\": it.x,\n                                        \"data-offset-y\": it.y,\n                                        \"data-size-x\": it.sizeX,\n                                        \"data-size-y\": it.sizeY,\n                                        style: {\n                                            [\"--offset-x\"]: it.x,\n                                            [\"--offset-y\"]: it.y,\n                                            [\"--item-size-x\"]: it.sizeX,\n                                            [\"--item-size-y\"]: it.sizeY,\n                                            top: \"-999px\",\n                                            bottom: \"-999px\",\n                                            left: \"-999px\",\n                                            right: \"-999px\"\n                                        },\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"item__image absolute block overflow-hidden cursor-pointer bg-gray-200 transition-transform duration-300\",\n                                            role: \"button\",\n                                            tabIndex: 0,\n                                            \"aria-label\": it.alt || \"Open image\",\n                                            onClick: (e)=>{\n                                                if (performance.now() - lastDragEndAt.current < 80) return;\n                                                openItemFromElement(e.currentTarget);\n                                            },\n                                            onTouchEnd: (e)=>{\n                                                if (performance.now() - lastDragEndAt.current < 80) return;\n                                                openItemFromElement(e.currentTarget);\n                                            },\n                                            style: {\n                                                inset: \"10px\",\n                                                borderRadius: \"var(--tile-radius, \".concat(imageBorderRadius, \")\"),\n                                                backfaceVisibility: \"hidden\"\n                                            },\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: it.src,\n                                                draggable: false,\n                                                alt: it.alt,\n                                                className: \"w-full h-full object-cover pointer-events-none\",\n                                                style: {\n                                                    backfaceVisibility: \"hidden\",\n                                                    filter: \"var(--image-filter, \".concat(grayscale ? \"grayscale(1)\" : \"none\", \")\")\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                                lineNumber: 823,\n                                                columnNumber: 21\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                            lineNumber: 804,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, \"\".concat(it.x, \",\").concat(it.y, \",\").concat(i), false, {\n                                        fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                        lineNumber: 782,\n                                        columnNumber: 17\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                lineNumber: 780,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 779,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute inset-0 m-auto z-[3] pointer-events-none\",\n                            style: {\n                                backgroundImage: \"radial-gradient(rgba(235, 235, 235, 0) 65%, var(--overlay-blur-color, \".concat(overlayBlurColor, \") 100%)\")\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 839,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute inset-0 m-auto z-[3] pointer-events-none\",\n                            style: {\n                                WebkitMaskImage: \"radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, \".concat(overlayBlurColor, \") 90%)\"),\n                                maskImage: \"radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, \".concat(overlayBlurColor, \") 90%)\"),\n                                backdropFilter: \"blur(3px)\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 846,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute left-0 right-0 top-0 h-[120px] z-[5] pointer-events-none rotate-180\",\n                            style: {\n                                background: \"linear-gradient(to bottom, transparent, var(--overlay-blur-color, \".concat(overlayBlurColor, \"))\")\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 855,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"absolute left-0 right-0 bottom-0 h-[120px] z-[5] pointer-events-none\",\n                            style: {\n                                background: \"linear-gradient(to bottom, transparent, var(--overlay-blur-color, \".concat(overlayBlurColor, \"))\")\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 861,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            ref: viewerRef,\n                            className: \"absolute inset-0 z-20 pointer-events-none flex items-center justify-center\",\n                            style: {\n                                padding: \"var(--viewer-pad)\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    ref: scrimRef,\n                                    className: \"scrim absolute inset-0 z-10 pointer-events-none opacity-0 transition-opacity duration-500\",\n                                    style: {\n                                        background: \"rgba(0, 0, 0, 0.4)\",\n                                        backdropFilter: \"blur(3px)\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                    lineNumber: 873,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    ref: frameRef,\n                                    className: \"viewer-frame h-full aspect-square flex\",\n                                    style: {\n                                        borderRadius: \"var(--enlarge-radius, \".concat(openedImageBorderRadius, \")\")\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                                    lineNumber: 881,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                            lineNumber: 868,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                    lineNumber: 769,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/kirniy/dev/nexus-website/nexus-web/src/components/ui/DomeGallery.tsx\",\n                lineNumber: 755,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(DomeGallery, \"xNnrqRuvZVMUudP+IMWRHoj1fw0=\", false, function() {\n    return [\n        _use_gesture_react__WEBPACK_IMPORTED_MODULE_2__.useGesture\n    ];\n});\n_c = DomeGallery;\nvar _c;\n$RefreshReg$(_c, \"DomeGallery\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0RvbWVHYWxsZXJ5LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWdFO0FBQ2hCO0FBaUNoRCxNQUFNSyxpQkFBOEI7SUFDbEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsV0FBVztJQUNmQyx3QkFBd0I7SUFDeEJDLGlCQUFpQjtJQUNqQkMscUJBQXFCO0lBQ3JCQyxVQUFVO0FBQ1o7QUFFQSxNQUFNQyxRQUFRLENBQUNDLEdBQVdDLEtBQWFDLE1BQWdCQyxLQUFLRixHQUFHLENBQUNFLEtBQUtELEdBQUcsQ0FBQ0YsR0FBR0MsTUFBTUM7QUFDbEYsTUFBTUUsaUJBQWlCLENBQUNDLElBQWMsQ0FBQyxJQUFLLE1BQU8sR0FBRSxJQUFLO0FBQzFELE1BQU1DLGtCQUFrQixDQUFDQztJQUN2QixNQUFNQyxJQUFJLENBQUMsQ0FBRUQsTUFBTSxHQUFFLElBQUssTUFBTyxHQUFFLElBQUs7SUFDeEMsT0FBT0MsSUFBSTtBQUNiO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUNDLElBQWlCQyxNQUFjQztRQUN2Q0Y7SUFBYixNQUFNRyxPQUFPSCxDQUFBQSxtQkFBQUEsR0FBR0ksT0FBTyxDQUFDSCxLQUFLLGNBQWhCRCw4QkFBQUEsbUJBQW9CQSxHQUFHSyxZQUFZLENBQUMsUUFBYSxPQUFMSjtJQUN6RCxNQUFNSyxJQUFJSCxRQUFRLE9BQU9JLE1BQU1DLFdBQVdMO0lBQzFDLE9BQU9NLE9BQU9DLFFBQVEsQ0FBQ0osS0FBS0EsSUFBSUo7QUFDbEM7QUFFQSxTQUFTUyxXQUFXQyxJQUFpQixFQUFFQyxHQUFXO0lBQ2hELE1BQU1DLFFBQVFDLE1BQU1DLElBQUksQ0FBQztRQUFFQyxRQUFRSjtJQUFJLEdBQUcsQ0FBQ0ssR0FBR0MsSUFBTSxDQUFDLEtBQUtBLElBQUk7SUFDOUQsTUFBTUMsU0FBUztRQUFDLENBQUM7UUFBRyxDQUFDO1FBQUc7UUFB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M0c2TixXQUFXLHlFQUEwRixPQUFqQjdOLGtCQUFpQjtnQ0FDckc4TixnQkFBZ0I7NEJBQ2xCOzs7Ozs7c0NBR0YsOERBQUM3Qjs0QkFDQ3hDLFdBQVU7NEJBQ1YvRyxPQUFPO2dDQUNMcUwsWUFBWSxxRUFBc0YsT0FBakIvTixrQkFBaUI7NEJBQ3BHOzs7Ozs7c0NBRUYsOERBQUNpTTs0QkFDQ3hDLFdBQVU7NEJBQ1YvRyxPQUFPO2dDQUNMcUwsWUFBWSxxRUFBc0YsT0FBakIvTixrQkFBaUI7NEJBQ3BHOzs7Ozs7c0NBR0YsOERBQUNpTTs0QkFDQ0MsS0FBS3ZMOzRCQUNMOEksV0FBVTs0QkFDVi9HLE9BQU87Z0NBQUVzTCxTQUFTOzRCQUFvQjs7OENBRXRDLDhEQUFDL0I7b0NBQ0NDLEtBQUt0TDtvQ0FDTDZJLFdBQVU7b0NBQ1YvRyxPQUFPO3dDQUNMcUwsWUFBWTt3Q0FDWkQsZ0JBQWdCO29DQUNsQjs7Ozs7OzhDQUVGLDhEQUFDN0I7b0NBQ0NDLEtBQUt4TDtvQ0FDTCtJLFdBQVU7b0NBQ1YvRyxPQUFPO3dDQUNMNkssY0FBYyx5QkFBaUQsT0FBeEJsTix5QkFBd0I7b0NBQ2pFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT2Q7R0Fwd0J3QmI7O1FBZ050QmpFLDBEQUFVQTs7O0tBaE5ZaUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvRG9tZUdhbGxlcnkudHN4PzZmZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlR2VzdHVyZSB9IGZyb20gJ0B1c2UtZ2VzdHVyZS9yZWFjdCc7XG5cbnR5cGUgSW1hZ2VJdGVtID0gc3RyaW5nIHwgeyBzcmM6IHN0cmluZzsgYWx0Pzogc3RyaW5nIH07XG5cbnR5cGUgRG9tZUdhbGxlcnlQcm9wcyA9IHtcbiAgaW1hZ2VzPzogSW1hZ2VJdGVtW107XG4gIGZpdD86IG51bWJlcjtcbiAgZml0QmFzaXM/OiAnYXV0bycgfCAnbWluJyB8ICdtYXgnIHwgJ3dpZHRoJyB8ICdoZWlnaHQnO1xuICBtaW5SYWRpdXM/OiBudW1iZXI7XG4gIG1heFJhZGl1cz86IG51bWJlcjtcbiAgcGFkRmFjdG9yPzogbnVtYmVyO1xuICBvdmVybGF5Qmx1ckNvbG9yPzogc3RyaW5nO1xuICBtYXhWZXJ0aWNhbFJvdGF0aW9uRGVnPzogbnVtYmVyO1xuICBkcmFnU2Vuc2l0aXZpdHk/OiBudW1iZXI7XG4gIGVubGFyZ2VUcmFuc2l0aW9uTXM/OiBudW1iZXI7XG4gIHNlZ21lbnRzPzogbnVtYmVyO1xuICBkcmFnRGFtcGVuaW5nPzogbnVtYmVyO1xuICBvcGVuZWRJbWFnZVdpZHRoPzogc3RyaW5nO1xuICBvcGVuZWRJbWFnZUhlaWdodD86IHN0cmluZztcbiAgaW1hZ2VCb3JkZXJSYWRpdXM/OiBzdHJpbmc7XG4gIG9wZW5lZEltYWdlQm9yZGVyUmFkaXVzPzogc3RyaW5nO1xuICBncmF5c2NhbGU/OiBib29sZWFuO1xufTtcblxudHlwZSBJdGVtRGVmID0ge1xuICBzcmM6IHN0cmluZztcbiAgYWx0OiBzdHJpbmc7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBzaXplWDogbnVtYmVyO1xuICBzaXplWTogbnVtYmVyO1xufTtcblxuY29uc3QgREVGQVVMVF9JTUFHRVM6IEltYWdlSXRlbVtdID0gW1xuICBcIi9waG90b18yMDI1LTA5LTIwXzAwLTM1LTEzLmpwZWdcIixcbiAgXCIvcGhvdG9fMjAyNS0wOS0yMF8wMC0zNS0xNC5qcGVnXCIsXG4gIFwiL3Bob3RvXzIwMjUtMDktMjBfMDAtMzUtMTYuanBlZ1wiLFxuICBcIi9waG90b18yMDI1LTA5LTIwXzAwLTM1LTE3LmpwZWdcIixcbiAgXCIvcGhvdG9fMjAyNS0wOS0yMF8wMC0zNS0xOC5qcGVnXCIsXG4gIFwiL3Bob3RvXzIwMjUtMDktMjBfMDAtMzUtMTkuanBlZ1wiLFxuICBcIi9waG90b18yMDI1LTA5LTIwXzAwLTM1LTIyLmpwZWdcIixcbiAgXCIvcGhvdG9fMjAyNS0wOS0yMF8wMC0zNS0yMy5qcGVnXCIsXG5dO1xuXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgbWF4VmVydGljYWxSb3RhdGlvbkRlZzogNSxcbiAgZHJhZ1NlbnNpdGl2aXR5OiAyMCxcbiAgZW5sYXJnZVRyYW5zaXRpb25NczogMzAwLFxuICBzZWdtZW50czogMzVcbn07XG5cbmNvbnN0IGNsYW1wID0gKHY6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuY29uc3Qgbm9ybWFsaXplQW5nbGUgPSAoZDogbnVtYmVyKSA9PiAoKGQgJSAzNjApICsgMzYwKSAlIDM2MDtcbmNvbnN0IHdyYXBBbmdsZVNpZ25lZCA9IChkZWc6IG51bWJlcikgPT4ge1xuICBjb25zdCBhID0gKCgoZGVnICsgMTgwKSAlIDM2MCkgKyAzNjApICUgMzYwO1xuICByZXR1cm4gYSAtIDE4MDtcbn07XG5jb25zdCBnZXREYXRhTnVtYmVyID0gKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogc3RyaW5nLCBmYWxsYmFjazogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGF0dHIgPSBlbC5kYXRhc2V0W25hbWVdID8/IGVsLmdldEF0dHJpYnV0ZShgZGF0YS0ke25hbWV9YCk7XG4gIGNvbnN0IG4gPSBhdHRyID09IG51bGwgPyBOYU4gOiBwYXJzZUZsb2F0KGF0dHIpO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IGZhbGxiYWNrO1xufTtcblxuZnVuY3Rpb24gYnVpbGRJdGVtcyhwb29sOiBJbWFnZUl0ZW1bXSwgc2VnOiBudW1iZXIpOiBJdGVtRGVmW10ge1xuICBjb25zdCB4Q29scyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNlZyB9LCAoXywgaSkgPT4gLTM3ICsgaSAqIDIpO1xuICBjb25zdCBldmVuWXMgPSBbLTQsIC0yLCAwLCAyLCA0XTtcbiAgY29uc3Qgb2RkWXMgPSBbLTMsIC0xLCAxLCAzLCA1XTtcblxuICBjb25zdCBjb29yZHMgPSB4Q29scy5mbGF0TWFwKCh4LCBjKSA9PiB7XG4gICAgY29uc3QgeXMgPSBjICUgMiA9PT0gMCA/IGV2ZW5ZcyA6IG9kZFlzO1xuICAgIHJldHVybiB5cy5tYXAoeSA9PiAoeyB4LCB5LCBzaXplWDogMiwgc2l6ZVk6IDIgfSkpO1xuICB9KTtcblxuICBjb25zdCB0b3RhbFNsb3RzID0gY29vcmRzLmxlbmd0aDtcbiAgaWYgKHBvb2wubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvb3Jkcy5tYXAoYyA9PiAoeyAuLi5jLCBzcmM6ICcnLCBhbHQ6ICcnIH0pKTtcbiAgfVxuICBpZiAocG9vbC5sZW5ndGggPiB0b3RhbFNsb3RzKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFtEb21lR2FsbGVyeV0gUHJvdmlkZWQgaW1hZ2UgY291bnQgKCR7cG9vbC5sZW5ndGh9KSBleGNlZWRzIGF2YWlsYWJsZSB0aWxlcyAoJHt0b3RhbFNsb3RzfSkuIFNvbWUgaW1hZ2VzIHdpbGwgbm90IGJlIHNob3duLmBcbiAgICApO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZEltYWdlcyA9IHBvb2wubWFwKGltYWdlID0+IHtcbiAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgc3JjOiBpbWFnZSwgYWx0OiAnJyB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzcmM6IGltYWdlLnNyYyB8fCAnJywgYWx0OiBpbWFnZS5hbHQgfHwgJycgfTtcbiAgfSk7XG5cbiAgY29uc3QgdXNlZEltYWdlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRvdGFsU2xvdHMgfSwgKF8sIGkpID0+IG5vcm1hbGl6ZWRJbWFnZXNbaSAlIG5vcm1hbGl6ZWRJbWFnZXMubGVuZ3RoXSk7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB1c2VkSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHVzZWRJbWFnZXNbaV0uc3JjID09PSB1c2VkSW1hZ2VzW2kgLSAxXS5zcmMpIHtcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHVzZWRJbWFnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHVzZWRJbWFnZXNbal0uc3JjICE9PSB1c2VkSW1hZ2VzW2ldLnNyYykge1xuICAgICAgICAgIGNvbnN0IHRtcCA9IHVzZWRJbWFnZXNbaV07XG4gICAgICAgICAgdXNlZEltYWdlc1tpXSA9IHVzZWRJbWFnZXNbal07XG4gICAgICAgICAgdXNlZEltYWdlc1tqXSA9IHRtcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29yZHMubWFwKChjLCBpKSA9PiAoe1xuICAgIC4uLmMsXG4gICAgc3JjOiB1c2VkSW1hZ2VzW2ldLnNyYyxcbiAgICBhbHQ6IHVzZWRJbWFnZXNbaV0uYWx0XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUl0ZW1CYXNlUm90YXRpb24ob2Zmc2V0WDogbnVtYmVyLCBvZmZzZXRZOiBudW1iZXIsIHNpemVYOiBudW1iZXIsIHNpemVZOiBudW1iZXIsIHNlZ21lbnRzOiBudW1iZXIpIHtcbiAgY29uc3QgdW5pdCA9IDM2MCAvIHNlZ21lbnRzIC8gMjtcbiAgY29uc3Qgcm90YXRlWSA9IHVuaXQgKiAob2Zmc2V0WCArIChzaXplWCAtIDEpIC8gMik7XG4gIGNvbnN0IHJvdGF0ZVggPSB1bml0ICogKG9mZnNldFkgLSAoc2l6ZVkgLSAxKSAvIDIpO1xuICByZXR1cm4geyByb3RhdGVYLCByb3RhdGVZIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERvbWVHYWxsZXJ5KHtcbiAgaW1hZ2VzID0gREVGQVVMVF9JTUFHRVMsXG4gIGZpdCA9IDAuNSxcbiAgZml0QmFzaXMgPSAnYXV0bycsXG4gIG1pblJhZGl1cyA9IDYwMCxcbiAgbWF4UmFkaXVzID0gSW5maW5pdHksXG4gIHBhZEZhY3RvciA9IDAuMjUsXG4gIG92ZXJsYXlCbHVyQ29sb3IgPSAnIzA2MDAxMCcsXG4gIG1heFZlcnRpY2FsUm90YXRpb25EZWcgPSBERUZBVUxUUy5tYXhWZXJ0aWNhbFJvdGF0aW9uRGVnLFxuICBkcmFnU2Vuc2l0aXZpdHkgPSBERUZBVUxUUy5kcmFnU2Vuc2l0aXZpdHksXG4gIGVubGFyZ2VUcmFuc2l0aW9uTXMgPSBERUZBVUxUUy5lbmxhcmdlVHJhbnNpdGlvbk1zLFxuICBzZWdtZW50cyA9IERFRkFVTFRTLnNlZ21lbnRzLFxuICBkcmFnRGFtcGVuaW5nID0gMixcbiAgb3BlbmVkSW1hZ2VXaWR0aCA9ICc0MDBweCcsXG4gIG9wZW5lZEltYWdlSGVpZ2h0ID0gJzQwMHB4JyxcbiAgaW1hZ2VCb3JkZXJSYWRpdXMgPSAnMzBweCcsXG4gIG9wZW5lZEltYWdlQm9yZGVyUmFkaXVzID0gJzMwcHgnLFxuICBncmF5c2NhbGUgPSB0cnVlXG59OiBEb21lR2FsbGVyeVByb3BzKSB7XG4gIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBtYWluUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgc3BoZXJlUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgZnJhbWVSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB2aWV3ZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBzY3JpbVJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGZvY3VzZWRFbFJlZiA9IHVzZVJlZjxIVE1MRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBvcmlnaW5hbFRpbGVQb3NpdGlvblJlZiA9IHVzZVJlZjx7XG4gICAgbGVmdDogbnVtYmVyO1xuICAgIHRvcDogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gIH0gfCBudWxsPihudWxsKTtcblxuICBjb25zdCByb3RhdGlvblJlZiA9IHVzZVJlZih7IHg6IDAsIHk6IDAgfSk7XG4gIGNvbnN0IHN0YXJ0Um90UmVmID0gdXNlUmVmKHsgeDogMCwgeTogMCB9KTtcbiAgY29uc3Qgc3RhcnRQb3NSZWYgPSB1c2VSZWY8eyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGRyYWdnaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2FuY2VsVGFwUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgbW92ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpbmVydGlhUkFGID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IHVzZVJlZjwnbW91c2UnIHwgJ3BlbicgfCAndG91Y2gnPignbW91c2UnKTtcbiAgY29uc3QgdGFwVGFyZ2V0UmVmID0gdXNlUmVmPEhUTUxFbGVtZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IG9wZW5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBvcGVuU3RhcnRlZEF0UmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBsYXN0RHJhZ0VuZEF0ID0gdXNlUmVmKDApO1xuXG4gIGNvbnN0IHNjcm9sbExvY2tlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGxvY2tTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHNjcm9sbExvY2tlZFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgc2Nyb2xsTG9ja2VkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZGctc2Nyb2xsLWxvY2snKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bmxvY2tTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzY3JvbGxMb2NrZWRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmIChyb290UmVmLmN1cnJlbnQ/LmdldEF0dHJpYnV0ZSgnZGF0YS1lbmxhcmdpbmcnKSA9PT0gJ3RydWUnKSByZXR1cm47XG4gICAgc2Nyb2xsTG9ja2VkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2RnLXNjcm9sbC1sb2NrJyk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBpdGVtcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGJ1aWx0SXRlbXMgPSBidWlsZEl0ZW1zKGltYWdlcywgc2VnbWVudHMpO1xuICAgIGNvbnNvbGUubG9nKCdEb21lR2FsbGVyeSBpdGVtczonLCBidWlsdEl0ZW1zKTtcbiAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGFycmF5OicsIGltYWdlcyk7XG4gICAgcmV0dXJuIGJ1aWx0SXRlbXM7XG4gIH0sIFtpbWFnZXMsIHNlZ21lbnRzXSk7XG5cbiAgY29uc3QgYXBwbHlUcmFuc2Zvcm0gPSAoeERlZzogbnVtYmVyLCB5RGVnOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBlbCA9IHNwaGVyZVJlZi5jdXJyZW50O1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVooY2FsYyh2YXIoLS1yYWRpdXMpICogLTEpKSByb3RhdGVYKCR7eERlZ31kZWcpIHJvdGF0ZVkoJHt5RGVnfWRlZylgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBsb2NrZWRSYWRpdXNSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByb290ID0gcm9vdFJlZi5jdXJyZW50O1xuICAgIGlmICghcm9vdCkgcmV0dXJuO1xuICAgIGNvbnN0IHJvID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgY3IgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgY29uc3QgdyA9IE1hdGgubWF4KDEsIGNyLndpZHRoKSxcbiAgICAgICAgaCA9IE1hdGgubWF4KDEsIGNyLmhlaWdodCk7XG4gICAgICBjb25zdCBtaW5EaW0gPSBNYXRoLm1pbih3LCBoKSxcbiAgICAgICAgbWF4RGltID0gTWF0aC5tYXgodywgaCksXG4gICAgICAgIGFzcGVjdCA9IHcgLyBoO1xuICAgICAgbGV0IGJhc2lzOiBudW1iZXI7XG4gICAgICBzd2l0Y2ggKGZpdEJhc2lzKSB7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgYmFzaXMgPSBtaW5EaW07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgYmFzaXMgPSBtYXhEaW07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICBiYXNpcyA9IHc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgYmFzaXMgPSBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJhc2lzID0gYXNwZWN0ID49IDEuMyA/IHcgOiBtaW5EaW07XG4gICAgICB9XG4gICAgICBsZXQgcmFkaXVzID0gYmFzaXMgKiBmaXQ7XG4gICAgICBjb25zdCBoZWlnaHRHdWFyZCA9IGggKiAxLjM1O1xuICAgICAgcmFkaXVzID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHRHdWFyZCk7XG4gICAgICByYWRpdXMgPSBjbGFtcChyYWRpdXMsIG1pblJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICAgIGxvY2tlZFJhZGl1c1JlZi5jdXJyZW50ID0gTWF0aC5yb3VuZChyYWRpdXMpO1xuXG4gICAgICBjb25zdCB2aWV3ZXJQYWQgPSBNYXRoLm1heCg4LCBNYXRoLnJvdW5kKG1pbkRpbSAqIHBhZEZhY3RvcikpO1xuICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgQ1NTIHZhcmlhYmxlczonLCB7XG4gICAgICAgIHJhZGl1czogbG9ja2VkUmFkaXVzUmVmLmN1cnJlbnQsXG4gICAgICAgIHZpZXdlclBhZCxcbiAgICAgICAgZGltZW5zaW9uczogeyB3LCBoIH1cbiAgICAgIH0pO1xuICAgICAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yYWRpdXMnLCBgJHtsb2NrZWRSYWRpdXNSZWYuY3VycmVudH1weGApO1xuICAgICAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aWV3ZXItcGFkJywgYCR7dmlld2VyUGFkfXB4YCk7XG4gICAgICByb290LnN0eWxlLnNldFByb3BlcnR5KCctLW92ZXJsYXktYmx1ci1jb2xvcicsIG92ZXJsYXlCbHVyQ29sb3IpO1xuICAgICAgcm9vdC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS10aWxlLXJhZGl1cycsIGltYWdlQm9yZGVyUmFkaXVzKTtcbiAgICAgIHJvb3Quc3R5bGUuc2V0UHJvcGVydHkoJy0tZW5sYXJnZS1yYWRpdXMnLCBvcGVuZWRJbWFnZUJvcmRlclJhZGl1cyk7XG4gICAgICByb290LnN0eWxlLnNldFByb3BlcnR5KCctLWltYWdlLWZpbHRlcicsIGdyYXlzY2FsZSA/ICdncmF5c2NhbGUoMSknIDogJ25vbmUnKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHJvdGF0aW9uUmVmLmN1cnJlbnQueCwgcm90YXRpb25SZWYuY3VycmVudC55KTtcblxuICAgICAgY29uc3QgZW5sYXJnZWRPdmVybGF5ID0gdmlld2VyUmVmLmN1cnJlbnQ/LnF1ZXJ5U2VsZWN0b3IoJy5lbmxhcmdlJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBpZiAoZW5sYXJnZWRPdmVybGF5ICYmIGZyYW1lUmVmLmN1cnJlbnQgJiYgbWFpblJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGZyYW1lUiA9IGZyYW1lUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IG1haW5SID0gbWFpblJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGNvbnN0IGhhc0N1c3RvbVNpemUgPSBvcGVuZWRJbWFnZVdpZHRoICYmIG9wZW5lZEltYWdlSGVpZ2h0O1xuICAgICAgICBpZiAoaGFzQ3VzdG9tU2l6ZSkge1xuICAgICAgICAgIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LnN0eWxlLmNzc1RleHQgPSBgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogJHtvcGVuZWRJbWFnZVdpZHRofTsgaGVpZ2h0OiAke29wZW5lZEltYWdlSGVpZ2h0fTsgdmlzaWJpbGl0eTogaGlkZGVuO2A7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRGl2KTtcbiAgICAgICAgICBjb25zdCB0ZW1wUmVjdCA9IHRlbXBEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRGl2KTtcblxuICAgICAgICAgIGNvbnN0IGNlbnRlcmVkTGVmdCA9IGZyYW1lUi5sZWZ0IC0gbWFpblIubGVmdCArIChmcmFtZVIud2lkdGggLSB0ZW1wUmVjdC53aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbnN0IGNlbnRlcmVkVG9wID0gZnJhbWVSLnRvcCAtIG1haW5SLnRvcCArIChmcmFtZVIuaGVpZ2h0IC0gdGVtcFJlY3QuaGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgICBlbmxhcmdlZE92ZXJsYXkuc3R5bGUubGVmdCA9IGAke2NlbnRlcmVkTGVmdH1weGA7XG4gICAgICAgICAgZW5sYXJnZWRPdmVybGF5LnN0eWxlLnRvcCA9IGAke2NlbnRlcmVkVG9wfXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmxhcmdlZE92ZXJsYXkuc3R5bGUubGVmdCA9IGAke2ZyYW1lUi5sZWZ0IC0gbWFpblIubGVmdH1weGA7XG4gICAgICAgICAgZW5sYXJnZWRPdmVybGF5LnN0eWxlLnRvcCA9IGAke2ZyYW1lUi50b3AgLSBtYWluUi50b3B9cHhgO1xuICAgICAgICAgIGVubGFyZ2VkT3ZlcmxheS5zdHlsZS53aWR0aCA9IGAke2ZyYW1lUi53aWR0aH1weGA7XG4gICAgICAgICAgZW5sYXJnZWRPdmVybGF5LnN0eWxlLmhlaWdodCA9IGAke2ZyYW1lUi5oZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm8ub2JzZXJ2ZShyb290KTtcbiAgICByZXR1cm4gKCkgPT4gcm8uZGlzY29ubmVjdCgpO1xuICB9LCBbXG4gICAgZml0LFxuICAgIGZpdEJhc2lzLFxuICAgIG1pblJhZGl1cyxcbiAgICBtYXhSYWRpdXMsXG4gICAgcGFkRmFjdG9yLFxuICAgIG92ZXJsYXlCbHVyQ29sb3IsXG4gICAgZ3JheXNjYWxlLFxuICAgIGltYWdlQm9yZGVyUmFkaXVzLFxuICAgIG9wZW5lZEltYWdlQm9yZGVyUmFkaXVzLFxuICAgIG9wZW5lZEltYWdlV2lkdGgsXG4gICAgb3BlbmVkSW1hZ2VIZWlnaHRcbiAgXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhcHBseVRyYW5zZm9ybShyb3RhdGlvblJlZi5jdXJyZW50LngsIHJvdGF0aW9uUmVmLmN1cnJlbnQueSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzdG9wSW5lcnRpYSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoaW5lcnRpYVJBRi5jdXJyZW50KSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpbmVydGlhUkFGLmN1cnJlbnQpO1xuICAgICAgaW5lcnRpYVJBRi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBzdGFydEluZXJ0aWEgPSB1c2VDYWxsYmFjayhcbiAgICAodng6IG51bWJlciwgdnk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgTUFYX1YgPSAxLjQ7XG4gICAgICBsZXQgdlggPSBjbGFtcCh2eCwgLU1BWF9WLCBNQVhfVikgKiA4MDtcbiAgICAgIGxldCB2WSA9IGNsYW1wKHZ5LCAtTUFYX1YsIE1BWF9WKSAqIDgwO1xuICAgICAgbGV0IGZyYW1lcyA9IDA7XG4gICAgICBjb25zdCBkID0gY2xhbXAoZHJhZ0RhbXBlbmluZyA/PyAwLjYsIDAsIDEpO1xuICAgICAgY29uc3QgZnJpY3Rpb25NdWwgPSAwLjk0ICsgMC4wNTUgKiBkO1xuICAgICAgY29uc3Qgc3RvcFRocmVzaG9sZCA9IDAuMDE1IC0gMC4wMSAqIGQ7XG4gICAgICBjb25zdCBtYXhGcmFtZXMgPSBNYXRoLnJvdW5kKDkwICsgMjcwICogZCk7XG4gICAgICBjb25zdCBzdGVwID0gKCkgPT4ge1xuICAgICAgICB2WCAqPSBmcmljdGlvbk11bDtcbiAgICAgICAgdlkgKj0gZnJpY3Rpb25NdWw7XG4gICAgICAgIGlmIChNYXRoLmFicyh2WCkgPCBzdG9wVGhyZXNob2xkICYmIE1hdGguYWJzKHZZKSA8IHN0b3BUaHJlc2hvbGQpIHtcbiAgICAgICAgICBpbmVydGlhUkFGLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKytmcmFtZXMgPiBtYXhGcmFtZXMpIHtcbiAgICAgICAgICBpbmVydGlhUkFGLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0WCA9IGNsYW1wKHJvdGF0aW9uUmVmLmN1cnJlbnQueCAtIHZZIC8gMjAwLCAtbWF4VmVydGljYWxSb3RhdGlvbkRlZywgbWF4VmVydGljYWxSb3RhdGlvbkRlZyk7XG4gICAgICAgIGNvbnN0IG5leHRZID0gd3JhcEFuZ2xlU2lnbmVkKHJvdGF0aW9uUmVmLmN1cnJlbnQueSArIHZYIC8gMjAwKTtcbiAgICAgICAgcm90YXRpb25SZWYuY3VycmVudCA9IHsgeDogbmV4dFgsIHk6IG5leHRZIH07XG4gICAgICAgIGFwcGx5VHJhbnNmb3JtKG5leHRYLCBuZXh0WSk7XG4gICAgICAgIGluZXJ0aWFSQUYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgIH07XG4gICAgICBzdG9wSW5lcnRpYSgpO1xuICAgICAgaW5lcnRpYVJBRi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH0sXG4gICAgW2RyYWdEYW1wZW5pbmcsIG1heFZlcnRpY2FsUm90YXRpb25EZWcsIHN0b3BJbmVydGlhXVxuICApO1xuXG4gIHVzZUdlc3R1cmUoXG4gICAge1xuICAgICAgb25EcmFnU3RhcnQ6ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgaWYgKGZvY3VzZWRFbFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIHN0b3BJbmVydGlhKCk7XG5cbiAgICAgICAgY29uc3QgZXZ0ID0gZXZlbnQgYXMgUG9pbnRlckV2ZW50O1xuICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gKGV2dC5wb2ludGVyVHlwZSBhcyBhbnkpIHx8ICdtb3VzZSc7XG4gICAgICAgIGlmIChwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSAndG91Y2gnKSBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcpIGxvY2tTY3JvbGwoKTtcbiAgICAgICAgZHJhZ2dpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNhbmNlbFRhcFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIG1vdmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgc3RhcnRSb3RSZWYuY3VycmVudCA9IHsgLi4ucm90YXRpb25SZWYuY3VycmVudCB9O1xuICAgICAgICBzdGFydFBvc1JlZi5jdXJyZW50ID0geyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfTtcbiAgICAgICAgY29uc3QgcG90ZW50aWFsID0gKGV2dC50YXJnZXQgYXMgRWxlbWVudCkuY2xvc2VzdD8uKCcuaXRlbV9faW1hZ2UnKSBhcyBIVE1MRWxlbWVudCB8IG51bGw7XG4gICAgICAgIHRhcFRhcmdldFJlZi5jdXJyZW50ID0gcG90ZW50aWFsIHx8IG51bGw7XG4gICAgICB9LFxuICAgICAgb25EcmFnOiAoeyBldmVudCwgbGFzdCwgdmVsb2NpdHk6IHZlbEFyciA9IFswLCAwXSwgZGlyZWN0aW9uOiBkaXJBcnIgPSBbMCwgMF0sIG1vdmVtZW50IH0pID0+IHtcbiAgICAgICAgaWYgKGZvY3VzZWRFbFJlZi5jdXJyZW50IHx8ICFkcmFnZ2luZ1JlZi5jdXJyZW50IHx8ICFzdGFydFBvc1JlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZXZ0ID0gZXZlbnQgYXMgUG9pbnRlckV2ZW50O1xuICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJykgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3QgZHhUb3RhbCA9IGV2dC5jbGllbnRYIC0gc3RhcnRQb3NSZWYuY3VycmVudC54O1xuICAgICAgICBjb25zdCBkeVRvdGFsID0gZXZ0LmNsaWVudFkgLSBzdGFydFBvc1JlZi5jdXJyZW50Lnk7XG5cbiAgICAgICAgaWYgKCFtb3ZlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc3QgZGlzdDIgPSBkeFRvdGFsICogZHhUb3RhbCArIGR5VG90YWwgKiBkeVRvdGFsO1xuICAgICAgICAgIGlmIChkaXN0MiA+IDE2KSBtb3ZlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRYID0gY2xhbXAoXG4gICAgICAgICAgc3RhcnRSb3RSZWYuY3VycmVudC54IC0gZHlUb3RhbCAvIGRyYWdTZW5zaXRpdml0eSxcbiAgICAgICAgICAtbWF4VmVydGljYWxSb3RhdGlvbkRlZyxcbiAgICAgICAgICBtYXhWZXJ0aWNhbFJvdGF0aW9uRGVnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG5leHRZID0gc3RhcnRSb3RSZWYuY3VycmVudC55ICsgZHhUb3RhbCAvIGRyYWdTZW5zaXRpdml0eTtcblxuICAgICAgICBjb25zdCBjdXIgPSByb3RhdGlvblJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY3VyLnggIT09IG5leHRYIHx8IGN1ci55ICE9PSBuZXh0WSkge1xuICAgICAgICAgIHJvdGF0aW9uUmVmLmN1cnJlbnQgPSB7IHg6IG5leHRYLCB5OiBuZXh0WSB9O1xuICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKG5leHRYLCBuZXh0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIGRyYWdnaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgaXNUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChzdGFydFBvc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkeCA9IGV2dC5jbGllbnRYIC0gc3RhcnRQb3NSZWYuY3VycmVudC54O1xuICAgICAgICAgICAgY29uc3QgZHkgPSBldnQuY2xpZW50WSAtIHN0YXJ0UG9zUmVmLmN1cnJlbnQueTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICBjb25zdCBUQVBfVEhSRVNIX1BYID0gcG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJyA/IDEwIDogNjtcbiAgICAgICAgICAgIGlmIChkaXN0MiA8PSBUQVBfVEhSRVNIX1BYICogVEFQX1RIUkVTSF9QWCkge1xuICAgICAgICAgICAgICBpc1RhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IFt2TWFnWCwgdk1hZ1ldID0gdmVsQXJyO1xuICAgICAgICAgIGNvbnN0IFtkaXJYLCBkaXJZXSA9IGRpckFycjtcbiAgICAgICAgICBsZXQgdnggPSB2TWFnWCAqIGRpclg7XG4gICAgICAgICAgbGV0IHZ5ID0gdk1hZ1kgKiBkaXJZO1xuXG4gICAgICAgICAgaWYgKCFpc1RhcCAmJiBNYXRoLmFicyh2eCkgPCAwLjAwMSAmJiBNYXRoLmFicyh2eSkgPCAwLjAwMSAmJiBBcnJheS5pc0FycmF5KG1vdmVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgW214LCBteV0gPSBtb3ZlbWVudDtcbiAgICAgICAgICAgIHZ4ID0gKG14IC8gZHJhZ1NlbnNpdGl2aXR5KSAqIDAuMDI7XG4gICAgICAgICAgICB2eSA9IChteSAvIGRyYWdTZW5zaXRpdml0eSkgKiAwLjAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNUYXAgJiYgKE1hdGguYWJzKHZ4KSA+IDAuMDA1IHx8IE1hdGguYWJzKHZ5KSA+IDAuMDA1KSkge1xuICAgICAgICAgICAgc3RhcnRJbmVydGlhKHZ4LCB2eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0UG9zUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGNhbmNlbFRhcFJlZi5jdXJyZW50ID0gIWlzVGFwO1xuXG4gICAgICAgICAgaWYgKGlzVGFwICYmIHRhcFRhcmdldFJlZi5jdXJyZW50ICYmICFmb2N1c2VkRWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgb3Blbkl0ZW1Gcm9tRWxlbWVudCh0YXBUYXJnZXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcFRhcmdldFJlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjYW5jZWxUYXBSZWYuY3VycmVudCkgc2V0VGltZW91dCgoKSA9PiAoY2FuY2VsVGFwUmVmLmN1cnJlbnQgPSBmYWxzZSksIDEyMCk7XG4gICAgICAgICAgaWYgKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPT09ICd0b3VjaCcpIHVubG9ja1Njcm9sbCgpO1xuICAgICAgICAgIGlmIChtb3ZlZFJlZi5jdXJyZW50KSBsYXN0RHJhZ0VuZEF0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBtb3ZlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHsgdGFyZ2V0OiBtYWluUmVmLCBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogZmFsc2UgfSB9XG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzY3JpbSA9IHNjcmltUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFzY3JpbSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBvcGVuU3RhcnRlZEF0UmVmLmN1cnJlbnQgPCAyNTApIHJldHVybjtcbiAgICAgIGNvbnN0IGVsID0gZm9jdXNlZEVsUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuICAgICAgY29uc3Qgb3ZlcmxheSA9IHZpZXdlclJlZi5jdXJyZW50Py5xdWVyeVNlbGVjdG9yKCcuZW5sYXJnZScpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICAgIGlmICghb3ZlcmxheSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCByZWZEaXYgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignLml0ZW1fX2ltYWdlLS1yZWZlcmVuY2UnKSBhcyBIVE1MRWxlbWVudCB8IG51bGw7XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsUG9zID0gb3JpZ2luYWxUaWxlUG9zaXRpb25SZWYuY3VycmVudDtcbiAgICAgIGlmICghb3JpZ2luYWxQb3MpIHtcbiAgICAgICAgb3ZlcmxheS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHJlZkRpdikgcmVmRGl2LnJlbW92ZSgpO1xuICAgICAgICBwYXJlbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tcm90LXktZGVsdGEnLCBgMGRlZ2ApO1xuICAgICAgICBwYXJlbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tcm90LXgtZGVsdGEnLCBgMGRlZ2ApO1xuICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIChlbC5zdHlsZSBhcyBhbnkpLnpJbmRleCA9IDA7XG4gICAgICAgIGZvY3VzZWRFbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcm9vdFJlZi5jdXJyZW50Py5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZW5sYXJnaW5nJyk7XG4gICAgICAgIG9wZW5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRSZWN0ID0gb3ZlcmxheS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJvb3RSZWN0ID0gcm9vdFJlZi5jdXJyZW50IS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxQb3NSZWxhdGl2ZVRvUm9vdCA9IHtcbiAgICAgICAgbGVmdDogb3JpZ2luYWxQb3MubGVmdCAtIHJvb3RSZWN0LmxlZnQsXG4gICAgICAgIHRvcDogb3JpZ2luYWxQb3MudG9wIC0gcm9vdFJlY3QudG9wLFxuICAgICAgICB3aWR0aDogb3JpZ2luYWxQb3Mud2lkdGgsXG4gICAgICAgIGhlaWdodDogb3JpZ2luYWxQb3MuaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvdmVybGF5UmVsYXRpdmVUb1Jvb3QgPSB7XG4gICAgICAgIGxlZnQ6IGN1cnJlbnRSZWN0LmxlZnQgLSByb290UmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IGN1cnJlbnRSZWN0LnRvcCAtIHJvb3RSZWN0LnRvcCxcbiAgICAgICAgd2lkdGg6IGN1cnJlbnRSZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGN1cnJlbnRSZWN0LmhlaWdodFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYW5pbWF0aW5nT3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYW5pbWF0aW5nT3ZlcmxheS5jbGFzc05hbWUgPSAnZW5sYXJnZS1jbG9zaW5nJztcbiAgICAgIGFuaW1hdGluZ092ZXJsYXkuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAke292ZXJsYXlSZWxhdGl2ZVRvUm9vdC5sZWZ0fXB4O1xuICAgICAgICB0b3A6ICR7b3ZlcmxheVJlbGF0aXZlVG9Sb290LnRvcH1weDtcbiAgICAgICAgd2lkdGg6ICR7b3ZlcmxheVJlbGF0aXZlVG9Sb290LndpZHRofXB4O1xuICAgICAgICBoZWlnaHQ6ICR7b3ZlcmxheVJlbGF0aXZlVG9Sb290LmhlaWdodH1weDtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogJHtvcGVuZWRJbWFnZUJvcmRlclJhZGl1c307XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMTBweCAzMHB4IHJnYmEoMCwwLDAsLjM1KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsICR7ZW5sYXJnZVRyYW5zaXRpb25Nc31tcyBlYXNlLW91dDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lO1xuICAgICAgICBmaWx0ZXI6ICR7Z3JheXNjYWxlID8gJ2dyYXlzY2FsZSgxKScgOiAnbm9uZSd9O1xuICAgICAgYDtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxJbWcgPSBvdmVybGF5LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgaWYgKG9yaWdpbmFsSW1nKSB7XG4gICAgICAgIGNvbnN0IGltZyA9IG9yaWdpbmFsSW1nLmNsb25lTm9kZSgpIGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IG9iamVjdC1maXQ6IGNvdmVyOyc7XG4gICAgICAgIGFuaW1hdGluZ092ZXJsYXkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH1cblxuICAgICAgb3ZlcmxheS5yZW1vdmUoKTtcbiAgICAgIHJvb3RSZWYuY3VycmVudCEuYXBwZW5kQ2hpbGQoYW5pbWF0aW5nT3ZlcmxheSk7XG5cbiAgICAgIHZvaWQgYW5pbWF0aW5nT3ZlcmxheS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgYW5pbWF0aW5nT3ZlcmxheS5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxQb3NSZWxhdGl2ZVRvUm9vdC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgYW5pbWF0aW5nT3ZlcmxheS5zdHlsZS50b3AgPSBvcmlnaW5hbFBvc1JlbGF0aXZlVG9Sb290LnRvcCArICdweCc7XG4gICAgICAgIGFuaW1hdGluZ092ZXJsYXkuc3R5bGUud2lkdGggPSBvcmlnaW5hbFBvc1JlbGF0aXZlVG9Sb290LndpZHRoICsgJ3B4JztcbiAgICAgICAgYW5pbWF0aW5nT3ZlcmxheS5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbFBvc1JlbGF0aXZlVG9Sb290LmhlaWdodCArICdweCc7XG4gICAgICAgIGFuaW1hdGluZ092ZXJsYXkuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBhbmltYXRpbmdPdmVybGF5LnJlbW92ZSgpO1xuICAgICAgICBvcmlnaW5hbFRpbGVQb3NpdGlvblJlZi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAocmVmRGl2KSByZWZEaXYucmVtb3ZlKCk7XG4gICAgICAgIHBhcmVudC5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuXG4gICAgICAgIHBhcmVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yb3QteS1kZWx0YScsIGAwZGVnYCk7XG4gICAgICAgIHBhcmVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1yb3QteC1kZWx0YScsIGAwZGVnYCk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICAoZWwuc3R5bGUgYXMgYW55KS56SW5kZXggPSAwO1xuICAgICAgICAgIGZvY3VzZWRFbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByb290UmVmLmN1cnJlbnQ/LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1lbmxhcmdpbmcnKTtcblxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDMwMG1zIGVhc2Utb3V0JztcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgICAgICAgICAgICBvcGVuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdnaW5nUmVmLmN1cnJlbnQgJiYgcm9vdFJlZi5jdXJyZW50Py5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW5sYXJnaW5nJykgIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdkZy1zY3JvbGwtbG9jaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGFuaW1hdGluZ092ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNsZWFudXAsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNjcmltLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2UpO1xuICAgIGNvbnN0IG9uS2V5ID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIGNsb3NlKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5KTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzY3JpbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsb3NlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXkpO1xuICAgIH07XG4gIH0sIFtlbmxhcmdlVHJhbnNpdGlvbk1zLCBvcGVuZWRJbWFnZUJvcmRlclJhZGl1cywgZ3JheXNjYWxlXSk7XG5cbiAgY29uc3Qgb3Blbkl0ZW1Gcm9tRWxlbWVudCA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBpZiAoY2FuY2VsVGFwUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAob3BlbmluZ1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgb3BlbmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBvcGVuU3RhcnRlZEF0UmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsb2NrU2Nyb2xsKCk7XG4gICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICBmb2N1c2VkRWxSZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1mb2N1c2VkJywgJ3RydWUnKTtcbiAgICBjb25zdCBvZmZzZXRYID0gZ2V0RGF0YU51bWJlcihwYXJlbnQsICdvZmZzZXRYJywgMCk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGdldERhdGFOdW1iZXIocGFyZW50LCAnb2Zmc2V0WScsIDApO1xuICAgIGNvbnN0IHNpemVYID0gZ2V0RGF0YU51bWJlcihwYXJlbnQsICdzaXplWCcsIDIpO1xuICAgIGNvbnN0IHNpemVZID0gZ2V0RGF0YU51bWJlcihwYXJlbnQsICdzaXplWScsIDIpO1xuICAgIGNvbnN0IHBhcmVudFJvdCA9IGNvbXB1dGVJdGVtQmFzZVJvdGF0aW9uKG9mZnNldFgsIG9mZnNldFksIHNpemVYLCBzaXplWSwgc2VnbWVudHMpO1xuICAgIGNvbnN0IHBhcmVudFkgPSBub3JtYWxpemVBbmdsZShwYXJlbnRSb3Qucm90YXRlWSk7XG4gICAgY29uc3QgZ2xvYmFsWSA9IG5vcm1hbGl6ZUFuZ2xlKHJvdGF0aW9uUmVmLmN1cnJlbnQueSk7XG4gICAgbGV0IHJvdFkgPSAtKHBhcmVudFkgKyBnbG9iYWxZKSAlIDM2MDtcbiAgICBpZiAocm90WSA8IC0xODApIHJvdFkgKz0gMzYwO1xuICAgIGNvbnN0IHJvdFggPSAtcGFyZW50Um90LnJvdGF0ZVggLSByb3RhdGlvblJlZi5jdXJyZW50Lng7XG4gICAgcGFyZW50LnN0eWxlLnNldFByb3BlcnR5KCctLXJvdC15LWRlbHRhJywgYCR7cm90WX1kZWdgKTtcbiAgICBwYXJlbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tcm90LXgtZGVsdGEnLCBgJHtyb3RYfWRlZ2ApO1xuICAgIGNvbnN0IHJlZkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJlZkRpdi5jbGFzc05hbWUgPSAnaXRlbV9faW1hZ2UgaXRlbV9faW1hZ2UtLXJlZmVyZW5jZSBvcGFjaXR5LTAnO1xuICAgIHJlZkRpdi5zdHlsZS50cmFuc2Zvcm0gPSBgcm90YXRlWCgkey1wYXJlbnRSb3Qucm90YXRlWH1kZWcpIHJvdGF0ZVkoJHstcGFyZW50Um90LnJvdGF0ZVl9ZGVnKWA7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHJlZkRpdik7XG4gICAgY29uc3QgdGlsZVIgPSByZWZEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgbWFpblIgPSBtYWluUmVmLmN1cnJlbnQhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGZyYW1lUiA9IGZyYW1lUmVmLmN1cnJlbnQhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIG9yaWdpbmFsVGlsZVBvc2l0aW9uUmVmLmN1cnJlbnQgPSB7XG4gICAgICBsZWZ0OiB0aWxlUi5sZWZ0LFxuICAgICAgdG9wOiB0aWxlUi50b3AsXG4gICAgICB3aWR0aDogdGlsZVIud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRpbGVSLmhlaWdodFxuICAgIH07XG4gICAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIChlbC5zdHlsZSBhcyBhbnkpLnpJbmRleCA9IDA7XG4gICAgY29uc3Qgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG92ZXJsYXkuY2xhc3NOYW1lID0gJ2VubGFyZ2UnO1xuICAgIG92ZXJsYXkuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDoke2ZyYW1lUi5sZWZ0IC0gbWFpblIubGVmdH1weDsgdG9wOiR7ZnJhbWVSLnRvcCAtIG1haW5SLnRvcH1weDsgd2lkdGg6JHtmcmFtZVIud2lkdGh9cHg7IGhlaWdodDoke2ZyYW1lUi5oZWlnaHR9cHg7IG9wYWNpdHk6MDsgei1pbmRleDozMDsgd2lsbC1jaGFuZ2U6dHJhbnNmb3JtLG9wYWNpdHk7IHRyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7IHRyYW5zaXRpb246dHJhbnNmb3JtICR7ZW5sYXJnZVRyYW5zaXRpb25Nc31tcyBlYXNlLCBvcGFjaXR5ICR7ZW5sYXJnZVRyYW5zaXRpb25Nc31tcyBlYXNlOyBib3JkZXItcmFkaXVzOiR7b3BlbmVkSW1hZ2VCb3JkZXJSYWRpdXN9OyBvdmVyZmxvdzpoaWRkZW47IGJveC1zaGFkb3c6MCAxMHB4IDMwcHggcmdiYSgwLDAsMCwuMzUpO2A7XG4gICAgY29uc3QgcmF3U3JjID0gcGFyZW50LmRhdGFzZXQuc3JjIHx8IChlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKSBhcyBIVE1MSW1hZ2VFbGVtZW50KT8uc3JjIHx8ICcnO1xuICAgIGNvbnN0IHJhd0FsdCA9IHBhcmVudC5kYXRhc2V0LmFsdCB8fCAoZWwucXVlcnlTZWxlY3RvcignaW1nJykgYXMgSFRNTEltYWdlRWxlbWVudCk/LmFsdCB8fCAnJztcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpbWcuc3JjID0gcmF3U3JjO1xuICAgIGltZy5hbHQgPSByYXdBbHQ7XG4gICAgaW1nLnN0eWxlLmNzc1RleHQgPSBgd2lkdGg6MTAwJTsgaGVpZ2h0OjEwMCU7IG9iamVjdC1maXQ6Y292ZXI7IGZpbHRlcjoke2dyYXlzY2FsZSA/ICdncmF5c2NhbGUoMSknIDogJ25vbmUnfTtgO1xuICAgIG92ZXJsYXkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB2aWV3ZXJSZWYuY3VycmVudCEuYXBwZW5kQ2hpbGQob3ZlcmxheSk7XG4gICAgY29uc3QgdHgwID0gdGlsZVIubGVmdCAtIGZyYW1lUi5sZWZ0O1xuICAgIGNvbnN0IHR5MCA9IHRpbGVSLnRvcCAtIGZyYW1lUi50b3A7XG4gICAgY29uc3Qgc3gwID0gdGlsZVIud2lkdGggLyBmcmFtZVIud2lkdGg7XG4gICAgY29uc3Qgc3kwID0gdGlsZVIuaGVpZ2h0IC8gZnJhbWVSLmhlaWdodDtcbiAgICBvdmVybGF5LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0eDB9cHgsICR7dHkwfXB4KSBzY2FsZSgke3N4MH0sICR7c3kwfSlgO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBvdmVybGF5LnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICBvdmVybGF5LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMHB4LCAwcHgpIHNjYWxlKDEsIDEpJztcbiAgICAgIHJvb3RSZWYuY3VycmVudD8uc2V0QXR0cmlidXRlKCdkYXRhLWVubGFyZ2luZycsICd0cnVlJyk7XG4gICAgfSk7XG4gICAgY29uc3Qgd2FudHNSZXNpemUgPSBvcGVuZWRJbWFnZVdpZHRoIHx8IG9wZW5lZEltYWdlSGVpZ2h0O1xuICAgIGlmICh3YW50c1Jlc2l6ZSkge1xuICAgICAgY29uc3Qgb25GaXJzdEVuZCA9IChldjogVHJhbnNpdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldi5wcm9wZXJ0eU5hbWUgIT09ICd0cmFuc2Zvcm0nKSByZXR1cm47XG4gICAgICAgIG92ZXJsYXkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIG9uRmlyc3RFbmQpO1xuICAgICAgICBjb25zdCBwcmV2VHJhbnNpdGlvbiA9IG92ZXJsYXkuc3R5bGUudHJhbnNpdGlvbjtcbiAgICAgICAgb3ZlcmxheS5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICBjb25zdCB0ZW1wV2lkdGggPSBvcGVuZWRJbWFnZVdpZHRoIHx8IGAke2ZyYW1lUi53aWR0aH1weGA7XG4gICAgICAgIGNvbnN0IHRlbXBIZWlnaHQgPSBvcGVuZWRJbWFnZUhlaWdodCB8fCBgJHtmcmFtZVIuaGVpZ2h0fXB4YDtcbiAgICAgICAgb3ZlcmxheS5zdHlsZS53aWR0aCA9IHRlbXBXaWR0aDtcbiAgICAgICAgb3ZlcmxheS5zdHlsZS5oZWlnaHQgPSB0ZW1wSGVpZ2h0O1xuICAgICAgICBjb25zdCBuZXdSZWN0ID0gb3ZlcmxheS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgb3ZlcmxheS5zdHlsZS53aWR0aCA9IGZyYW1lUi53aWR0aCArICdweCc7XG4gICAgICAgIG92ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gZnJhbWVSLmhlaWdodCArICdweCc7XG4gICAgICAgIHZvaWQgb3ZlcmxheS5vZmZzZXRXaWR0aDtcbiAgICAgICAgb3ZlcmxheS5zdHlsZS50cmFuc2l0aW9uID0gYGxlZnQgJHtlbmxhcmdlVHJhbnNpdGlvbk1zfW1zIGVhc2UsIHRvcCAke2VubGFyZ2VUcmFuc2l0aW9uTXN9bXMgZWFzZSwgd2lkdGggJHtlbmxhcmdlVHJhbnNpdGlvbk1zfW1zIGVhc2UsIGhlaWdodCAke2VubGFyZ2VUcmFuc2l0aW9uTXN9bXMgZWFzZWA7XG4gICAgICAgIGNvbnN0IGNlbnRlcmVkTGVmdCA9IGZyYW1lUi5sZWZ0IC0gbWFpblIubGVmdCArIChmcmFtZVIud2lkdGggLSBuZXdSZWN0LndpZHRoKSAvIDI7XG4gICAgICAgIGNvbnN0IGNlbnRlcmVkVG9wID0gZnJhbWVSLnRvcCAtIG1haW5SLnRvcCArIChmcmFtZVIuaGVpZ2h0IC0gbmV3UmVjdC5oZWlnaHQpIC8gMjtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBvdmVybGF5LnN0eWxlLmxlZnQgPSBgJHtjZW50ZXJlZExlZnR9cHhgO1xuICAgICAgICAgIG92ZXJsYXkuc3R5bGUudG9wID0gYCR7Y2VudGVyZWRUb3B9cHhgO1xuICAgICAgICAgIG92ZXJsYXkuc3R5bGUud2lkdGggPSB0ZW1wV2lkdGg7XG4gICAgICAgICAgb3ZlcmxheS5zdHlsZS5oZWlnaHQgPSB0ZW1wSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xlYW51cFNlY29uZCA9ICgpID0+IHtcbiAgICAgICAgICBvdmVybGF5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjbGVhbnVwU2Vjb25kKTtcbiAgICAgICAgICBvdmVybGF5LnN0eWxlLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2xlYW51cFNlY29uZCwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25GaXJzdEVuZCk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZGctc2Nyb2xsLWxvY2snKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY3NzU3R5bGVzID0gYFxuICAgIC5zcGhlcmUtcm9vdCB7XG4gICAgICAtLXJhZGl1czogODAwcHg7XG4gICAgICAtLXZpZXdlci1wYWQ6IDcycHg7XG4gICAgICAtLWNpcmM6IGNhbGModmFyKC0tcmFkaXVzKSAqIDMuMTQpO1xuICAgICAgLS1yb3QteTogY2FsYygoMzYwZGVnIC8gdmFyKC0tc2VnbWVudHMteCkpIC8gMik7XG4gICAgICAtLXJvdC14OiBjYWxjKCgzNjBkZWcgLyB2YXIoLS1zZWdtZW50cy15KSkgLyAyKTtcbiAgICAgIC0taXRlbS13aWR0aDogY2FsYyh2YXIoLS1jaXJjKSAvIHZhcigtLXNlZ21lbnRzLXgpKTtcbiAgICAgIC0taXRlbS1oZWlnaHQ6IGNhbGModmFyKC0tY2lyYykgLyB2YXIoLS1zZWdtZW50cy15KSk7XG4gICAgfVxuXG4gICAgLnNwaGVyZS1yb290ICogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XG4gICAgLnNwaGVyZSwgLnNwaGVyZS1pdGVtLCAuaXRlbV9faW1hZ2UgeyB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkOyB9XG5cbiAgICAuc3RhZ2Uge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAwO1xuICAgICAgbWFyZ2luOiBhdXRvO1xuICAgICAgcGVyc3BlY3RpdmU6IGNhbGModmFyKC0tcmFkaXVzKSAqIDIpO1xuICAgICAgcGVyc3BlY3RpdmUtb3JpZ2luOiA1MCUgNTAlO1xuICAgIH1cblxuICAgIC5zcGhlcmUge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKGNhbGModmFyKC0tcmFkaXVzKSAqIC0xKSk7XG4gICAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgLyogRGVidWc6IG1ha2Ugc3BoZXJlIHZpc2libGUgKi9cbiAgICAgIHdpZHRoOiAyMDBweDtcbiAgICAgIGhlaWdodDogMjAwcHg7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuc3BoZXJlLWl0ZW0ge1xuICAgICAgd2lkdGg6IGNhbGModmFyKC0taXRlbS13aWR0aCkgKiB2YXIoLS1pdGVtLXNpemUteCkpO1xuICAgICAgaGVpZ2h0OiBjYWxjKHZhcigtLWl0ZW0taGVpZ2h0KSAqIHZhcigtLWl0ZW0tc2l6ZS15KSk7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IC05OTlweDtcbiAgICAgIGJvdHRvbTogLTk5OXB4O1xuICAgICAgbGVmdDogLTk5OXB4O1xuICAgICAgcmlnaHQ6IC05OTlweDtcbiAgICAgIG1hcmdpbjogYXV0bztcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MCU7XG4gICAgICBiYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMzAwbXM7XG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZVkoY2FsYyh2YXIoLS1yb3QteSkgKiAodmFyKC0tb2Zmc2V0LXgpICsgKCh2YXIoLS1pdGVtLXNpemUteCkgLSAxKSAvIDIpKSArIHZhcigtLXJvdC15LWRlbHRhLCAwZGVnKSkpXG4gICAgICAgICAgICAgICAgIHJvdGF0ZVgoY2FsYyh2YXIoLS1yb3QteCkgKiAodmFyKC0tb2Zmc2V0LXkpIC0gKCh2YXIoLS1pdGVtLXNpemUteSkgLSAxKSAvIDIpKSArIHZhcigtLXJvdC14LWRlbHRhLCAwZGVnKSkpXG4gICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVoodmFyKC0tcmFkaXVzKSk7XG4gICAgfVxuXG4gICAgLnNwaGVyZS1yb290W2RhdGEtZW5sYXJnaW5nPVwidHJ1ZVwiXSAuc2NyaW0ge1xuICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgcG9pbnRlci1ldmVudHM6IGFsbCAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIEBtZWRpYSAobWF4LWFzcGVjdC1yYXRpbzogMS8xKSB7XG4gICAgICAudmlld2VyLWZyYW1lIHtcbiAgICAgICAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgICAgIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogYm9keS5kZy1zY3JvbGwtbG9jayB7XG4gICAgICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcbiAgICAgIHRvcDogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICAgICAgaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgICB0b3VjaC1hY3Rpb246IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW4gIWltcG9ydGFudDtcbiAgICB9ICovXG4gICAgLml0ZW1fX2ltYWdlIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAxMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tdGlsZS1yYWRpdXMsIDEycHgpO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIGJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDMwMG1zO1xuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICB9XG4gICAgLml0ZW1fX2ltYWdlLS1yZWZlcmVuY2Uge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaW5zZXQ6IDEwcHg7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG4gIGA7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPHN0eWxlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogY3NzU3R5bGVzIH19IC8+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17cm9vdFJlZn1cbiAgICAgICAgY2xhc3NOYW1lPVwic3BoZXJlLXJvb3QgcmVsYXRpdmUgdy1mdWxsIGgtZnVsbCBiZy1yZWQtNTAwLzEwXCJcbiAgICAgICAgc3R5bGU9e1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFsnLS1zZWdtZW50cy14JyBhcyBhbnldOiBzZWdtZW50cyxcbiAgICAgICAgICAgIFsnLS1zZWdtZW50cy15JyBhcyBhbnldOiBzZWdtZW50cyxcbiAgICAgICAgICAgIFsnLS1vdmVybGF5LWJsdXItY29sb3InIGFzIGFueV06IG92ZXJsYXlCbHVyQ29sb3IsXG4gICAgICAgICAgICBbJy0tdGlsZS1yYWRpdXMnIGFzIGFueV06IGltYWdlQm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgWyctLWVubGFyZ2UtcmFkaXVzJyBhcyBhbnldOiBvcGVuZWRJbWFnZUJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgIFsnLS1pbWFnZS1maWx0ZXInIGFzIGFueV06IGdyYXlzY2FsZSA/ICdncmF5c2NhbGUoMSknIDogJ25vbmUnXG4gICAgICAgICAgfSBhcyBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgID5cbiAgICAgICAgPG1haW5cbiAgICAgICAgICByZWY9e21haW5SZWZ9XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBncmlkIHBsYWNlLWl0ZW1zLWNlbnRlciBvdmVyZmxvdy1oaWRkZW4gc2VsZWN0LW5vbmUgYmctZ3JlZW4tNTAwLzEwXCJcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICAgICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhdXRvJyxcbiAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YWdlIGJnLWJsdWUtNTAwLzEwXCI+XG4gICAgICAgICAgICA8ZGl2IHJlZj17c3BoZXJlUmVmfSBjbGFzc05hbWU9XCJzcGhlcmUgYmcteWVsbG93LTUwMC8xMFwiPlxuICAgICAgICAgICAgICB7aXRlbXMubWFwKChpdCwgaSkgPT4gKFxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgIGtleT17YCR7aXQueH0sJHtpdC55fSwke2l9YH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNwaGVyZS1pdGVtIGFic29sdXRlIG0tYXV0b1wiXG4gICAgICAgICAgICAgICAgICBkYXRhLXNyYz17aXQuc3JjfVxuICAgICAgICAgICAgICAgICAgZGF0YS1hbHQ9e2l0LmFsdH1cbiAgICAgICAgICAgICAgICAgIGRhdGEtb2Zmc2V0LXg9e2l0Lnh9XG4gICAgICAgICAgICAgICAgICBkYXRhLW9mZnNldC15PXtpdC55fVxuICAgICAgICAgICAgICAgICAgZGF0YS1zaXplLXg9e2l0LnNpemVYfVxuICAgICAgICAgICAgICAgICAgZGF0YS1zaXplLXk9e2l0LnNpemVZfVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgWyctLW9mZnNldC14JyBhcyBhbnldOiBpdC54LFxuICAgICAgICAgICAgICAgICAgICAgIFsnLS1vZmZzZXQteScgYXMgYW55XTogaXQueSxcbiAgICAgICAgICAgICAgICAgICAgICBbJy0taXRlbS1zaXplLXgnIGFzIGFueV06IGl0LnNpemVYLFxuICAgICAgICAgICAgICAgICAgICAgIFsnLS1pdGVtLXNpemUteScgYXMgYW55XTogaXQuc2l6ZVksXG4gICAgICAgICAgICAgICAgICAgICAgdG9wOiAnLTk5OXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICBib3R0b206ICctOTk5cHgnLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6ICctOTk5cHgnLFxuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnLTk5OXB4J1xuICAgICAgICAgICAgICAgICAgICB9IGFzIFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIml0ZW1fX2ltYWdlIGFic29sdXRlIGJsb2NrIG92ZXJmbG93LWhpZGRlbiBjdXJzb3ItcG9pbnRlciBiZy1ncmF5LTIwMCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi0zMDBcIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2l0LmFsdCB8fCAnT3BlbiBpbWFnZSd9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIGxhc3REcmFnRW5kQXQuY3VycmVudCA8IDgwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgb3Blbkl0ZW1Gcm9tRWxlbWVudChlLmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBvblRvdWNoRW5kPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0RHJhZ0VuZEF0LmN1cnJlbnQgPCA4MCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgIG9wZW5JdGVtRnJvbUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICBpbnNldDogJzEwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogYHZhcigtLXRpbGUtcmFkaXVzLCAke2ltYWdlQm9yZGVyUmFkaXVzfSlgLFxuICAgICAgICAgICAgICAgICAgICAgIGJhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgIHNyYz17aXQuc3JjfVxuICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgYWx0PXtpdC5hbHR9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXIgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGB2YXIoLS1pbWFnZS1maWx0ZXIsICR7Z3JheXNjYWxlID8gJ2dyYXlzY2FsZSgxKScgOiAnbm9uZSd9KWBcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIG0tYXV0byB6LVszXSBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHJhZGlhbC1ncmFkaWVudChyZ2JhKDIzNSwgMjM1LCAyMzUsIDApIDY1JSwgdmFyKC0tb3ZlcmxheS1ibHVyLWNvbG9yLCAke292ZXJsYXlCbHVyQ29sb3J9KSAxMDAlKWBcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cblxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgbS1hdXRvIHotWzNdIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgV2Via2l0TWFza0ltYWdlOiBgcmFkaWFsLWdyYWRpZW50KHJnYmEoMjM1LCAyMzUsIDIzNSwgMCkgNzAlLCB2YXIoLS1vdmVybGF5LWJsdXItY29sb3IsICR7b3ZlcmxheUJsdXJDb2xvcn0pIDkwJSlgLFxuICAgICAgICAgICAgICBtYXNrSW1hZ2U6IGByYWRpYWwtZ3JhZGllbnQocmdiYSgyMzUsIDIzNSwgMjM1LCAwKSA3MCUsIHZhcigtLW92ZXJsYXktYmx1ci1jb2xvciwgJHtvdmVybGF5Qmx1ckNvbG9yfSkgOTAlKWAsXG4gICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiAnYmx1cigzcHgpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgbGVmdC0wIHJpZ2h0LTAgdG9wLTAgaC1bMTIwcHhdIHotWzVdIHBvaW50ZXItZXZlbnRzLW5vbmUgcm90YXRlLTE4MFwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdHJhbnNwYXJlbnQsIHZhcigtLW92ZXJsYXktYmx1ci1jb2xvciwgJHtvdmVybGF5Qmx1ckNvbG9yfSkpYFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGxlZnQtMCByaWdodC0wIGJvdHRvbS0wIGgtWzEyMHB4XSB6LVs1XSBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCB0cmFuc3BhcmVudCwgdmFyKC0tb3ZlcmxheS1ibHVyLWNvbG9yLCAke292ZXJsYXlCbHVyQ29sb3J9KSlgXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICByZWY9e3ZpZXdlclJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgei0yMCBwb2ludGVyLWV2ZW50cy1ub25lIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IHBhZGRpbmc6ICd2YXIoLS12aWV3ZXItcGFkKScgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIHJlZj17c2NyaW1SZWZ9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNjcmltIGFic29sdXRlIGluc2V0LTAgei0xMCBwb2ludGVyLWV2ZW50cy1ub25lIG9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tNTAwXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjQpJyxcbiAgICAgICAgICAgICAgICBiYWNrZHJvcEZpbHRlcjogJ2JsdXIoM3B4KSdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIHJlZj17ZnJhbWVSZWZ9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInZpZXdlci1mcmFtZSBoLWZ1bGwgYXNwZWN0LXNxdWFyZSBmbGV4XCJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGB2YXIoLS1lbmxhcmdlLXJhZGl1cywgJHtvcGVuZWRJbWFnZUJvcmRlclJhZGl1c30pYFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9tYWluPlxuICAgICAgPC9kaXY+XG4gICAgPC8+XG4gICk7XG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZUdlc3R1cmUiLCJERUZBVUxUX0lNQUdFUyIsIkRFRkFVTFRTIiwibWF4VmVydGljYWxSb3RhdGlvbkRlZyIsImRyYWdTZW5zaXRpdml0eSIsImVubGFyZ2VUcmFuc2l0aW9uTXMiLCJzZWdtZW50cyIsImNsYW1wIiwidiIsIm1pbiIsIm1heCIsIk1hdGgiLCJub3JtYWxpemVBbmdsZSIsImQiLCJ3cmFwQW5nbGVTaWduZWQiLCJkZWciLCJhIiwiZ2V0RGF0YU51bWJlciIsImVsIiwibmFtZSIsImZhbGxiYWNrIiwiYXR0ciIsImRhdGFzZXQiLCJnZXRBdHRyaWJ1dGUiLCJuIiwiTmFOIiwicGFyc2VGbG9hdCIsIk51bWJlciIsImlzRmluaXRlIiwiYnVpbGRJdGVtcyIsInBvb2wiLCJzZWciLCJ4Q29scyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIl8iLCJpIiwiZXZlbllzIiwib2RkWXMiLCJjb29yZHMiLCJmbGF0TWFwIiwieCIsImMiLCJ5cyIsIm1hcCIsInkiLCJzaXplWCIsInNpemVZIiwidG90YWxTbG90cyIsInNyYyIsImFsdCIsImNvbnNvbGUiLCJ3YXJuIiwibm9ybWFsaXplZEltYWdlcyIsImltYWdlIiwidXNlZEltYWdlcyIsImoiLCJ0bXAiLCJjb21wdXRlSXRlbUJhc2VSb3RhdGlvbiIsIm9mZnNldFgiLCJvZmZzZXRZIiwidW5pdCIsInJvdGF0ZVkiLCJyb3RhdGVYIiwiRG9tZUdhbGxlcnkiLCJpbWFnZXMiLCJmaXQiLCJmaXRCYXNpcyIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsIkluZmluaXR5IiwicGFkRmFjdG9yIiwib3ZlcmxheUJsdXJDb2xvciIsImRyYWdEYW1wZW5pbmciLCJvcGVuZWRJbWFnZVdpZHRoIiwib3BlbmVkSW1hZ2VIZWlnaHQiLCJpbWFnZUJvcmRlclJhZGl1cyIsIm9wZW5lZEltYWdlQm9yZGVyUmFkaXVzIiwiZ3JheXNjYWxlIiwicm9vdFJlZiIsIm1haW5SZWYiLCJzcGhlcmVSZWYiLCJmcmFtZVJlZiIsInZpZXdlclJlZiIsInNjcmltUmVmIiwiZm9jdXNlZEVsUmVmIiwib3JpZ2luYWxUaWxlUG9zaXRpb25SZWYiLCJyb3RhdGlvblJlZiIsInN0YXJ0Um90UmVmIiwic3RhcnRQb3NSZWYiLCJkcmFnZ2luZ1JlZiIsImNhbmNlbFRhcFJlZiIsIm1vdmVkUmVmIiwiaW5lcnRpYVJBRiIsInBvaW50ZXJUeXBlUmVmIiwidGFwVGFyZ2V0UmVmIiwib3BlbmluZ1JlZiIsIm9wZW5TdGFydGVkQXRSZWYiLCJsYXN0RHJhZ0VuZEF0Iiwic2Nyb2xsTG9ja2VkUmVmIiwibG9ja1Njcm9sbCIsImN1cnJlbnQiLCJkb2N1bWVudCIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJ1bmxvY2tTY3JvbGwiLCJyZW1vdmUiLCJpdGVtcyIsImJ1aWx0SXRlbXMiLCJsb2ciLCJhcHBseVRyYW5zZm9ybSIsInhEZWciLCJ5RGVnIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJsb2NrZWRSYWRpdXNSZWYiLCJyb290Iiwicm8iLCJSZXNpemVPYnNlcnZlciIsImVudHJpZXMiLCJjciIsImNvbnRlbnRSZWN0IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsIm1pbkRpbSIsIm1heERpbSIsImFzcGVjdCIsImJhc2lzIiwicmFkaXVzIiwiaGVpZ2h0R3VhcmQiLCJyb3VuZCIsInZpZXdlclBhZCIsImRpbWVuc2lvbnMiLCJzZXRQcm9wZXJ0eSIsImVubGFyZ2VkT3ZlcmxheSIsInF1ZXJ5U2VsZWN0b3IiLCJmcmFtZVIiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJtYWluUiIsImhhc0N1c3RvbVNpemUiLCJ0ZW1wRGl2IiwiY3JlYXRlRWxlbWVudCIsImNzc1RleHQiLCJhcHBlbmRDaGlsZCIsInRlbXBSZWN0IiwicmVtb3ZlQ2hpbGQiLCJjZW50ZXJlZExlZnQiLCJsZWZ0IiwiY2VudGVyZWRUb3AiLCJ0b3AiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInN0b3BJbmVydGlhIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJzdGFydEluZXJ0aWEiLCJ2eCIsInZ5IiwiTUFYX1YiLCJ2WCIsInZZIiwiZnJhbWVzIiwiZnJpY3Rpb25NdWwiLCJzdG9wVGhyZXNob2xkIiwibWF4RnJhbWVzIiwic3RlcCIsImFicyIsIm5leHRYIiwibmV4dFkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvbkRyYWdTdGFydCIsImV2ZW50IiwiZXZ0IiwicG9pbnRlclR5cGUiLCJwcmV2ZW50RGVmYXVsdCIsImNsaWVudFgiLCJjbGllbnRZIiwicG90ZW50aWFsIiwidGFyZ2V0IiwiY2xvc2VzdCIsIm9uRHJhZyIsImxhc3QiLCJ2ZWxvY2l0eSIsInZlbEFyciIsImRpcmVjdGlvbiIsImRpckFyciIsIm1vdmVtZW50IiwiZHhUb3RhbCIsImR5VG90YWwiLCJkaXN0MiIsImN1ciIsImlzVGFwIiwiZHgiLCJkeSIsIlRBUF9USFJFU0hfUFgiLCJ2TWFnWCIsInZNYWdZIiwiZGlyWCIsImRpclkiLCJpc0FycmF5IiwibXgiLCJteSIsIm9wZW5JdGVtRnJvbUVsZW1lbnQiLCJzZXRUaW1lb3V0IiwicGVyZm9ybWFuY2UiLCJub3ciLCJldmVudE9wdGlvbnMiLCJwYXNzaXZlIiwic2NyaW0iLCJjbG9zZSIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJvdmVybGF5IiwicmVmRGl2Iiwib3JpZ2luYWxQb3MiLCJ2aXNpYmlsaXR5IiwiekluZGV4IiwicmVtb3ZlQXR0cmlidXRlIiwiY3VycmVudFJlY3QiLCJyb290UmVjdCIsIm9yaWdpbmFsUG9zUmVsYXRpdmVUb1Jvb3QiLCJvdmVybGF5UmVsYXRpdmVUb1Jvb3QiLCJhbmltYXRpbmdPdmVybGF5IiwiY2xhc3NOYW1lIiwib3JpZ2luYWxJbWciLCJpbWciLCJjbG9uZU5vZGUiLCJvcGFjaXR5IiwiY2xlYW51cCIsInRyYW5zaXRpb24iLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsIm9uS2V5IiwiZSIsImtleSIsIndpbmRvdyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRBdHRyaWJ1dGUiLCJwYXJlbnRSb3QiLCJwYXJlbnRZIiwiZ2xvYmFsWSIsInJvdFkiLCJyb3RYIiwidGlsZVIiLCJyYXdTcmMiLCJyYXdBbHQiLCJ0eDAiLCJ0eTAiLCJzeDAiLCJzeTAiLCJ3YW50c1Jlc2l6ZSIsIm9uRmlyc3RFbmQiLCJldiIsInByb3BlcnR5TmFtZSIsInByZXZUcmFuc2l0aW9uIiwidGVtcFdpZHRoIiwidGVtcEhlaWdodCIsIm5ld1JlY3QiLCJvZmZzZXRXaWR0aCIsImNsZWFudXBTZWNvbmQiLCJjc3NTdHlsZXMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImRpdiIsInJlZiIsIm1haW4iLCJ0b3VjaEFjdGlvbiIsIldlYmtpdFVzZXJTZWxlY3QiLCJwb2ludGVyRXZlbnRzIiwiaXQiLCJkYXRhLXNyYyIsImRhdGEtYWx0IiwiZGF0YS1vZmZzZXQteCIsImRhdGEtb2Zmc2V0LXkiLCJkYXRhLXNpemUteCIsImRhdGEtc2l6ZS15IiwiYm90dG9tIiwicmlnaHQiLCJyb2xlIiwidGFiSW5kZXgiLCJhcmlhLWxhYmVsIiwib25DbGljayIsImN1cnJlbnRUYXJnZXQiLCJvblRvdWNoRW5kIiwiaW5zZXQiLCJib3JkZXJSYWRpdXMiLCJiYWNrZmFjZVZpc2liaWxpdHkiLCJkcmFnZ2FibGUiLCJmaWx0ZXIiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJXZWJraXRNYXNrSW1hZ2UiLCJtYXNrSW1hZ2UiLCJiYWNrZHJvcEZpbHRlciIsImJhY2tncm91bmQiLCJwYWRkaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/DomeGallery.tsx\n"));

/***/ })

});